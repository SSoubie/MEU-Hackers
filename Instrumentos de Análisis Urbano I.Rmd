---
title: "Instrumentos de Análisis Urbano I"
author: "Florencia Kihara,  Victoria Marco y Santiago Soubie"
date: "6/6/2021"
output: html_document
---
# **TRABAJO PRÁCTICO FINAL**

*INTEGRANTES*
  - Florencia Kihara
  - Victoria Marco
  - Santiago Soubie

**Consigna**

*Debido a la pandemia del COVID-19, el Gobierno de la Ciudad de Buenos Aires tomó la decisión de reutilizar la capacidad hotelera preexistente para poder mejorar la capacidad de atención sanitaria para la población. Sin embargo, encontrar las ubicaciones óptimas no es una tarea trivial.*

*Por un lado, el presupuesto con el que cuenta el GCBA es limitado. Por otro lado, la zona donde estén estos nuevos centros de atención de pacientes va a depender de distintos factores como la accesibilidad y la densidad poblacional.*

*El objetivo de este trabajo es poder indicar las manzanas de la Ciudad de Buenos Aires de mayor viabilidad para el alquiler de algún inmueble en base a los siguientes criterios:*

*● Costo promedio de alquiler*

*● Métricas de accesibilidad (cercanía con avenidas, cercanía con una estación de subte y cualquier otra variable que les pueda parecer útil, tiempo de viaje, en minutos caminando o en auto, desde distintos puntos de la Ciudad)*

*● Densidad poblacional*


```{r}
library(tidyverse)
library(sf)
library(leaflet)
library(hereR)
set_key("pcWH0YNYi1G1eqMvAM7fjHWMvqNOaKL6yprw1aMNCeU")
```
```{r}
options(scipen=100)
```

Nuestro trabajo consiste en identificar los hoteles con la mejor ubicación para mejorar la capacidad de atención sanitaria de la Ciudad de Buenos Aires (CABA). En consecuencia, utilizaremos distitos datasets (espaciales y no). Estos comprenden:

- Aquellos datasets vinculados a la organización territorial de la CABA

```{r}
barriosCABA <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/mapaCABA.geojson") 
```

```{r}
radiosCensales <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/radioscensales.geojson")
```

```{r}
manzanas <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/manzanas.geojson")
```

- Aquellos vinculados a la planta del transporte

```{r}
calles <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/callejero.geojson")
```

```{r}
subte <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/estacionsubte.geojson")
```

```{r}
metrobus <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/metrobus.geojson")
```

*Si observamos dentro del dataset "metrobus", veremos algunas paradas por fuera de la CABA. Vamos a quitarlas*

```{r}
metrobus <- filter(metrobus, METROBUS!="Metrobus Norte - Av Maipú (provincia)")
```

- Aquellos ligados a infraestructuras de salud

```{r}
hospitales <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/hospitales.geojson")
```

```{r}
csac <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/csac.geojson")
```

- Aquel que contiene los alojamientos de la CABA

```{r}
hoteles <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/alojamientos.geojson")
```

*Graficamos*

```{r fig.height=10, fig.width=10}
ggplot() + 
  geom_sf(data=barriosCABA, aes (fill=""), color="gray60")+
  geom_sf(data=hoteles, aes(color="Hoteles"), show.legend ="point", size=2)+
  geom_sf(data=hospitales,aes(color="Hospitales"), show.legend ="point", size=2)+
  geom_sf(data=subte,aes(color="Subte"), show.legend ="point", size=2)+
  scale_colour_manual(values= c("Hoteles"="olivedrab4","Hospitales"="hotpink4","Subte"="salmon"), name="Referencias",
                    guide=guide_legend(override.aes=list(linetype="blank")))+
  scale_fill_manual(values= c("NA"="white"),name=NULL,
                  guide=guide_legend(override.aes=list(linetype="blank",shape=NA)))+
  labs(title = "Ubicación de hoteles, estación de subte, hospitales de la Ciudad Autónoma de Buenos Aires ",
      caption = "Fuente: BA DATA")+
  theme_void()
```


- Aquel que posee el precio de las propiedades en alquiler

```{r}
properati <- read.csv("C:data/rent_properati_2020_2021_utf8.csv",
                      stringsAsFactors = TRUE,
                      encoding = "UTF-8")
```

*Al ser tantos registros, para asegurarnos de que la base de datos sólo contenga valores únicos, aplicaremos la función unique*

```{r}
properati <- unique(properati)
```

Empezaremos por trabajar sobre este último dataset debido a que es necesario intervenir el mismo para poder obtener la información necesaria para nuestro proyecto.

1º Extraemos el año de la columna "created_on" para poder filtrar los casos del año 2021.
2º Seleccionamos aquellos casos donde existe información precisa para la CABA.
3º Pesificamos los precios de los alquileres en dolares al valor de referencia de $150 a fin de homogeneizar la unidad de valor para todos los regitros. 
4º Eliminamos las columnas que no serán de utilidad para nuestro trabajo. 

```{r}
properati2021 <- properati %>% 
  separate(created_on, c("ano", "mes", "dia"), sep = "-") %>% 
  filter(ano=="2021" & l2=="Capital Federal" & price!="NA" & currency!="") %>% 
  mutate(precio=ifelse(currency=="USD", price*150, price*1)) %>% 
  rename(barrios=l3) %>% 
  select(-start_date, -end_date, -mes, -dia, -l4, -l5, -l6, -price, -currency)
```


Teniendo en cuenta que el objetivo final del trabajo es definir dónde se deberían instalar los centro de atención a pacientes Covid positivos leves, optamos por quedarnos unicamente con los registros correspondientes a Departamentos y Oficinas ya que consideramos que son el tipo de producto que permite albergar a muchas personas en un mismo edificio, procurando la mayor eficiencia posible de recursos humanos, para la atención de los pacientes (por ejemplo: en el caso de una casa, se podría atender a pocos pacientes, mientras que en un edificio, se podría atender a mayor cantidad de pacientes, con la misma cantidad de personal de la salud) .

```{r}
properati2021 <- filter(properati2021, property_type %in% c("Departamento", "Oficina"))
```

Ahora calcularemos el precio del metro cuadrado (m2). Para ello:

1º Quitaremos los casos que no cuenten con ninguna superficie medible (total y/o cubierta).
2º Crearemos una columna que contenga la superficie total, o, en detrimento, la cubierta.
3º Calcularemos el precio del m2.
4º Quitaremos los casos menores a 32 m2 (según Nuevo Código de Edificación de la Ciudad de Buenos Aires) y mayores a 75000m2 (para excluir del dataset, aquellos observaciones mayores que probablemente estaban mal cargadas).

```{r}
properati2021 <- properati2021 %>% 
  filter(!(surface_covered=="NA" & surface_total=="NA")) %>% 
  mutate(superficie=ifelse(is.na(surface_total), surface_covered, surface_total),
         metro2=precio/superficie,
         metro2=round(metro2,0)) %>% 
  filter(superficie>=32 & superficie<=7500)
```

Luego, queremos clasificar los alquileres en categorías según su valor. Entonces:

1º Creamos el vector que va a establecer los quiebres (quintiles)

```{r}
quiebres <- c(0,0.2,0.4,0.6,0.8,1)
```

2º Clasificamos los valores de acuerdo a categorías 

```{r}
properati2021 <- mutate(properati2021, catmetro2=cut(metro2,breaks = quantile(metro2,quiebres,na.rm = TRUE, dig.lab = 5),include.lowest = TRUE))
```

*Modificamos las etiquetas para que sea más simple comprenderlas*

```{r}
properati2021 <- mutate(properati2021, catmetro2=as.numeric(catmetro2),
                        catmetro2 = recode(catmetro2, "1"="Muy bajo", "2"="Bajo", "3"="Medio", "4"="Alto", "5"="Muy alto"))
```

Veamos que tenemos hasta el momento. Analicemos los valores del m2 de acuerdo a las dimensiones de los inmuebles. Para ello, primero clasifiquemos a los mismos en categorías de acuerdo a su tamaño. Luego, graficaremos.

```{r}
properati2021 <- mutate(properati2021, superficiecat=ifelse(superficie %in% 32:55, "Chico",
                                                     ifelse(superficie %in% 56:75, "Mediano",
                                                     ifelse(superficie %in% 76:150, "Grande", "Muy grande"))))
```


Comenzamos considerando unidades desde 32m2, medida mínima para unidad funcional que permite el Nuevo Código de Edificación de la Ciudad Autónoma de Buenos Aires; hasta 55m2 que se podría considerar un 2 ambientes grande.
Desde la óptica del mercado inmobiliario, las unidades hasta 75m2 son consideradas medianas y más allá de dicha superficie, son grandes y muy grandes.

```{r fig.height=5, fig.width=10}
options(scipen=100)

properati2021 <- mutate(properati2021, superficiecat=factor(superficiecat, levels = c ("Chico", "Mediano", "Grande", "Muy grande")))
ggplot(data = properati2021) +
    geom_boxplot(aes(x=superficiecat, y=metro2, color="salmon"), show.legend = FALSE)+
   labs(title ="Oficinas y departamentos en alquiler de la Ciudad Autónoma de Buenos Aires", 
       caption = "Fuente: Properati",
       x= "Tamaño",
       y= "Valor (m2)")
```

A partir de este boxplot, podemos ver que identificamos valores extremos que sesgan nuestra muestra. Por este motivo, nuestro siguiente paso será quitar todos aquellos casos en los que el valor del m2 supere los 50.000 pesos.

```{r}
properati2021 <- filter(properati2021, metro2<50000)
```

*Graficamos nuevamente*

```{r fig.height=5, fig.width=10}
ggplot(data = properati2021) +
    geom_boxplot(aes(x=superficiecat, y=metro2, color="salmon"), show.legend = FALSE)+
   labs(title ="Oficinas y departamentos en alquiler de la Ciudad Autónoma de Buenos Aires", 
       caption = "Fuente: Properati",
       x= "Tamaño",
       y= "Valor (m2)")
```

A través de este nuevo boxplot, podemos comprobar que continuan existiendo outliers, pero su magnitud no es tan extrema (comparativamente con los casos ya borrados), y, por lo tanto, no serán eliminados. 

Por último, procederemos a componer un mapa que nos permita visualizar la ubicación de las unidades de nuestro dataset, a fin de poder identificar las zonas más significativas para nuestro análisis. Con este fin:

1º Quitaremos todos los valores que no puedan ser ubicados en el mapa.

```{r}
properati2021 <- filter(properati2021, !(lon=="NA" & lat=="NA"))
```

2º Transformaremos nuestro dataset en uno espacial.

```{r}
properati2021 <- st_as_sf(properati2021,
                           coords = c("lon","lat"),
                           crs = 4326)
```

*Graficamos para ver nuestro resultado hasta el momento*


A continuación graficaremos el mapa donde veremos la distribución por barrios de las categorías consideradas anteriormente.

```{r fig.width=10, fig.height=10}
properati2021 <- mutate(properati2021, catmetro2=factor(catmetro2, levels = c ("Muy bajo", "Bajo", "Medio", "Alto", "Muy alto")))
ggplot()+
  geom_sf(data=barriosCABA) +
  geom_sf(data=properati2021, aes(color=catmetro2))+
  scale_color_viridis_d()+
  labs(title ="Oficinas y departamentos en alquiler en la Ciudad Autónoma de Buenos Aires", 
       caption = "Fuente: Properati",
       color="Categorías según valor de alquiler/m2")+
  theme_void()
```

3º Como podemos observar en nuestro dataset, la variable barrios contiene más que los que son oficialmente reconocidos. Para poder asignarlos de forma precisa, unimos nuestro dataset con el dataset "barriosCABA".

```{r}
properati2021<- st_join(barriosCABA,properati2021)
```

*Gracias a este último paso, podemos ver que los valores extremos de Versalles, en realidad, se encuentran mal geolocalizados. Vamos a quitarlos*

```{r}
filter(properati2021, barrio=="VERSALLES") 
```

```{r}
properati2021 <- filter(properati2021, !(barrio=="VERSALLES" & barrios=="Catalinas"))
```

4º Agrupamos los registros y calculamos la media del m2 por barrio.

```{r}
properati2021barrios <- properati2021 %>% 
  group_by(barrio) %>% 
  summarise(promediometro2=mean(metro2)) %>% 
  mutate(promediometro2=round(promediometro2, 2))
```

*Graficamos*

```{r fig.width=10, fig.height=10}
ggplot() +
  geom_sf(data=barriosCABA)+
  geom_sf (data=properati2021barrios, aes(fill=promediometro2)) +
  labs(title ="Alquiler promedio", 
       subtitle = "Por barrio de la Ciudad Autónoma de Buenos Aires",
       caption = "Fuente: Properati",
       fill="Valor de alquiler/m2")+
  scale_fill_viridis_c() +
  theme_void()
```

Por último, unimos nuestro dataset al de radios censales que contiene la información por barrio. Los barrios que aparecen en gris son los que no tienen ninguna oferta en el dataset Properati.

```{r}
properati2021barrios <- properati2021barrios %>% 
  as.data.frame() %>% 
  select(barrio, promediometro2) %>% 
  rename(BARRIO=barrio)
radiosCensales <- left_join(radiosCensales, properati2021barrios, by="BARRIO")
```



## **SEGUNDA PARTE: SELECCIONANDO LA MANZANA IDEAL**

Previo a seleccionar los hoteles con la mejor ubicación para mejorar la capacidad de atención sanitaria de la CABA, es necesario identificar las manzanas de la ciudad que cumplen con ciertos requisitos.

Puesto que trabajaremos con distintos datasets espaciales, homogeneizaremos los sistemas de coordenadas. Como referencia, utilizaremos el sitema de coordenadas que emplea el GCBA.

```{r}
hospitales <- st_transform(hospitales, crs="+proj=tmerc +lat_0=-34.6297166 +lon_0=-58.4627 +k=1 +x_0=100000 +y_0=100000 +ellps=intl +units=m +no_defs")
csac <- st_transform(csac, crs=st_crs(hospitales))
metrobus <- st_transform(metrobus, crs = st_crs(hospitales))
subte <- st_transform(subte, crs = st_crs(hospitales))
hoteles <- st_transform(hoteles, crs=st_crs(hospitales))
barriosCABA <- st_transform(barriosCABA, crs = st_crs(hospitales))
manzanas <- st_transform(manzanas, crs = st_crs(hospitales))
calles <- st_transform(calles, crs = st_crs(hospitales))
radiosCensales <- st_transform(radiosCensales, crs = st_crs(hospitales))
```

Queremos que las manzanas que elijamos se encuentren, como mucho, a 1000 mts de un hospitales públicos y a 1500 mts de un Csac.

```{r}
coberturaHospitales <- hospitales %>% 
    st_buffer(dist = 1000) %>%
    summarise(cobertura=TRUE)
```

```{r}
coberturacsac <- csac %>% 
    st_buffer(dist = 1500) %>%
    summarise(cobertura=TRUE)
```

La cercanías a centros de salud permitirá un rápido acceso en caso que los casos se agraven, y es por ello que luego veremos la importancia de considerar las redes de transporte



```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=barriosCABA, aes (fill=""), color="gray60")+
  geom_sf(data=coberturacsac, alpha=0.5, aes(fill="Cobertura Cesac"),show.legend=)+
  geom_sf(data=coberturaHospitales, alpha=0.5,aes(fill="Cobertura Hospitales"),show.legend = )+
  geom_sf(data=hoteles, size=1.5, aes(color="Hoteles"))+
  scale_fill_manual(values= c("NA"="white","Cobertura Hospitales"="olivedrab4","Cobertura Cesac"="lightblue4"), name="Referencias",
                    guide=guide_legend(override.aes=list(linetype="blank", shape=NA)))+
  scale_colour_manual(values= c("Hoteles"="black"), name= NULL)+
   labs(title = "Cobertura de centros de salud y ubicación de hoteles",
       caption = "Fuente: BA DATA")+
  theme_void()
```

Otra de las condiciones que debe cumplir nuestra manzana es que sea de fácil acceso. En este sentido, las mismas deben encontrarse a una distancia prudencial de las estaciones de subte, de metrobus y las avenidas. Con ello en mente:

1º Como un extremo de una manzana puede estar más cerca de una ubicación que otro y, a su vez, dado que una manzana puede poseer una forma irrregular, calcularemos la distancia desde el centro. Por este motivo, nuestro primer paso será extraer los centros de manzanas.

```{r}
manzanacentroide <- st_centroid(manzanas)
```

2º Hacemos un dataset que solo contenga las avenidas de CABA.

```{r}
avenidas <- filter(calles, tipo_c=="AVENIDA")
```

*Graficamos para ver los centroides de manzana*

Como hemos comentado anteriormente, las redes de transportes son relevantes para nuestro análisis, dado que la ubicación de los mismos van a permitir el fácil y rápido acceso a los centros de salud que determinemos.
Para poder visualizar las paradas de metrobus, estaciones de subte y avenidas de la Ciudad Autónoma de Buenos Aires, graficaremos el siguiente mapa.


```{r fig.height=10, fig.width=10}
ggplot()+ 
  geom_sf(data = manzanas, aes (fill = ""), size = 0.1, color="gray60") +
  geom_sf(data = manzanacentroide, aes (color = "Centroide de Manzana"), show.legend="point", size=0.1)+
  geom_sf(data = avenidas, aes (color = "Avenidas"), show.legend =)+
  geom_sf(data = subte, aes(color = "Subte"), show.legend="point", size=2)+
  geom_sf(data = metrobus, aes (color = "Metrobus"), show.legend="point", size=2)+
  scale_colour_manual(values = c("Centroide de Manzana" = "grey60", "Avenidas"="mediumvioletred", "Subte"="royalblue4", "Metrobus"="orange2"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  scale_fill_manual(values = c("NA"= "white"),name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
  labs(title = "Centros de manzana",
       subtitle = "Centros de manzana, Avenidas, Estaciones de Subte y Paradas de Metrobus",
       caption = "Fuente: BA DATA")+
  theme_void()
```

3º Calculamos la distancia desde los centroides de manzana a los distintos puntos de transporte

```{r}
distanciavenida <- st_distance(manzanacentroide, avenidas)
distanciasubte <- st_distance(manzanacentroide, subte)
distanciametrobus <- st_distance(manzanacentroide, metrobus)
```

4º Como el paso anterior nos devolvió todas las distacias posibles de nuestra manzana a todos los puntos de transporte, solo nos vamos a quedar con las de menor tamaño.

```{r}
avenidacercana <- apply(distanciavenida,1,function(x) min(x))
```

```{r}
subtecercano <- apply(distanciasubte,1, function(x) min(x))
metrobuscercano <- apply(distanciametrobus,1, function(x) min(x))
```

*Redondeamos los valores*

```{r}
avenidacercana <- round(avenidacercana, 0)
subtecercano <- round(subtecercano, 0)
metrobuscercano <- round(metrobuscercano, 0)
```

5º Agregamos las distancias al dataset de manzanas

```{r}
manzanas <- mutate(manzanas, distanciaavenida=avenidacercana,
                   distanciasubte=subtecercano,
                   distanciametrobus=metrobuscercano)
```

*Graficamos*

Hemos decidido considerar las distancias a avenidas, a la red de metrobus y a la red de subte para garantizarla accesibilidad en diversos medios de transportes, no sólo a pacientes sino a los trabajadores de la salud, como mencionamos con anterioridad. 

A continuación graficaremos las manzanas (Manzanas ideales) que cumplen con las condiciones que llamaremos "Condición 00":

-  Que esté a 500m de una parada de Metrobus,

-  Que esté a 500m de una estación de subte,

-  Que esté a 200m de una avenida.


```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, aes (fill=""), color="gray60")+
  geom_sf(data=filter(manzanas, distanciametrobus<=500 & distanciasubte<=500 & distanciaavenida<=200), aes (fill="Manzanas ideales"))+
  scale_fill_manual(values = c("NA"= "white", "Manzanas ideales"="olivedrab"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
  labs(title = "Manzanas ideales", 
       subtitle= "Según cercanía a las avenidas, las paradas de Metrobus y las estaciones de Subte",
       caption = "Fuente: BA DATA")+
  theme_void()
```

Retomemos la cuestión de la cobertura de los hospitales y Cesacs.

Nosotros solo nos interesa quedarnos con aquellas manzanas que se encuentren a menos de 1000 mts de los hospitales, y a 1500 mts de los Cesacs. Para averguar cuales son:

1º Unimos el dataset de centroides de manzana con los de cobertura de hospitales y Cesacs. 

```{r}
manzanacentroide <- st_join(manzanacentroide, coberturaHospitales)
manzanacentroide <- st_join(manzanacentroide, coberturacsac)
```

*Renombramos las columnas*

```{r}
manzanacentroide <- rename(manzanacentroide, "cobhospitales"=cobertura.x,
                           "cobcesac"=cobertura.y)
```

*Graficamos*

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data = manzanas, aes (fill=""), color="gray60")+
  geom_sf(data = filter(manzanacentroide, cobhospitales=="TRUE" & cobcesac=="TRUE"), aes (color="Manzanas ideales"), show.legend = "point")+
   scale_fill_manual(values = c("NA"= "white"),name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
   scale_colour_manual(values = c("Manzanas ideales"= "lightblue2"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  labs(title = "Manzanas ideales", 
       subtitle= "Según cobertura de centros de salud",
       caption = "Fuente: BA DATA")+
  theme_void()
```

Otro dato que tendremos en cuenta es el de densidad poblacional.

Nuestro objetivo es seleccionar aquellas manzanas que cumplan con un determinado parámetro de densidad. 
Para calcular la misma: 

1º Creamos una columna que contenga la población por km2 de cada radio censal.

```{r}
radiosCensales <- mutate(radiosCensales, densidadPob=round(POBLACION/AREA_KM2, 2))
```

*Graficamos*

```{r fig.height=10, fig.width=10}
ggplot() +
  geom_sf(data = radiosCensales, aes(fill=densidadPob))+
  labs(title = "Densidad poblacional en la Ciudad Autónoma de Buenos Aires ",
       subtitle = "Por manzana",
       fill= "Habitantes por km2",
       caption="Fuente: BA DATA")+
  scale_fill_viridis_c()+
  theme_void()
```

2º Unimos el dataset de los radios censales al de manzanas centroides.

```{r}
manzanacentroide <- st_join(manzanacentroide,radiosCensales)
```

Una vez finalizados estos pasos, seleccionamos las columnas de interés del dataset manzanascentroide y las volcamos a nuestro dataset de manzanas.

```{r}
manzanacentroide <- manzanacentroide %>% 
                      as.data.frame() %>%
                      select(SM, cobhospitales, cobcesac, promediometro2, densidadPob)
manzanas <- left_join(manzanas, manzanacentroide, by="SM")
```


*Al unir nuestros datasets, vemos que se suman más casos de los que debería haber (12588 frente a 12520). Averiguamos si se generaron duplicados*

```{r}
duplicados <- duplicated(manzanas, incomparables = FALSE)
```

```{r}
summary(duplicados)
```

*Efectivamente, algunos registros fueron duplicados. Por ello, procederemos  a quedarnos solo con los valores únicos*

```{r}
manzanas <- unique(manzanas)
```

Ahora, creamos un dataset que cuente con las manzanas que cumplen con las siguientes condiciones:

- que posea cobertura de hospitales

- que posea cobertura Cesacs

- que posea una densidad poblacional mayor o igual que la media por manzana de la CABA (media= 16576)

- que se encuentre a 500 mts o menos de una parada de metrobús

- que se encuentre a 500 mts o menos de una estación de subte

- que se encuentre a 200 mts o menos de una avenida

- que la manzana esté dentro de un barrio donde el valor del m2 de las unidades en alquiler sea menor o igual a la media de la ciudad (media= 642)

```{r}
manzanaselecta <- filter(manzanas, cobhospitales==TRUE & cobcesac==TRUE & densidadPob>=16576 & distanciametrobus<=500 & distanciasubte<=500 & distanciaavenida<=200 & promediometro2<=642)
```

Ahora graficaremos las manzanas que cumplen con estas condiciones y la ubicación de los hoteles de la Ciudad.


```{r fig.height=10, fig.width=10}
ggplot()+geom_sf(data=manzanas, aes(fill=""), color="gray60", size=0.2)+
        geom_sf(data=manzanaselecta, aes(fill="Manzanas ideales"))+
        geom_sf(data=hoteles, aes (color="Hoteles"), size=1, show.legend = "point")+
  scale_colour_manual(values = c(Hoteles="hotpink4"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  scale_fill_manual(values = c("Manzanas ideales"= "olivedrab4", "NA"="white"),name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
   labs(title = "Manzanas ideales para la ubicación de un centros de atención",
        subtitle = "Según criterios establecidos",
        caption="Fuente: BA DATA & Properati")+
        theme_void()
```

Al analizar el mapa, se puede observar que las manzanas que cumplen con las condiciones estipuladas son escasas. Esto va en detrimento de la escala que se quiere alcanzar para alivianar el sistema de salud. 



## **TERCERA PARTE: CONSTRUYENDO UN ÍNDICE**

Entendiendo que los parámetros que seleccionamos en este trabajo pueden ser valorados de distinta manera, hemos decidido construir un índice que pondere dichas variables.
 
Antes de avanzar en dicha dirección, debemos realizar algunas operaciones sobre las variables previamente mencionadas.

1º Considerando los quiebres indicados con anterioridad, dividiremos las variables en quintiles para normalizar los valores

```{r}
manzanas <- manzanas %>% 
            mutate(cat_densidad=cut(densidadPob,breaks = quantile(densidadPob,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciasubte=cut(-distanciasubte,breaks = quantile(-distanciasubte,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciametrobus=cut(-distanciametrobus,breaks = quantile(-distanciametrobus,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_promediom2=cut(-promediometro2,breaks = quantile(-promediometro2,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciavenida=cut(-distanciaavenida,breaks = quantile(-distanciaavenida,quiebres,na.rm = TRUE ),include.lowest = TRUE))
```

```{r}
manzanas<- mutate (manzanas, cobhospitales=ifelse(is.na(cobhospitales),"FALSE","TRUE"),
                   cobcesac=ifelse(is.na(cobcesac),"FALSE","TRUE"))
```

2º Luego, a cada categoría le asignaremos un valor numérico.

```{r}
manzanas <- manzanas %>% 
   mutate(cat_densidad=as.numeric(cat_densidad),
          cat_distanciasubte=as.numeric(cat_distanciasubte),
          cat_distanciametrobus=as.numeric(cat_distanciametrobus),
          cat_distanciavenida=as.numeric(cat_distanciavenida),
          cat_promediom2=as.numeric(cat_promediom2),
          cat_cobhospitales=ifelse(cobhospitales=="TRUE",2,1),
          cat_cobcesac=ifelse(cobcesac=="TRUE",2,1))
```

Ahora desarrollaremos el índice (Indice 01), considerando las siguientes ponderaciones sobre las variables:

- Densidad: 10%, dado que no consideramos que es una variable tan determinante a tener en cuenta

- Distancia subte: 15%, con el fin de permitir la accesibilidad a los centros de salud, del personal que atiende a los pacientes

- Distancia Metrobus: 15%, con el fin de permitir la accesibilidad a los centros de salud, del personal que atiende a los pacientes

- Cobertura hospitales: 35%,  es la variable que consideramos más importante, dado que, en el caso de que a un paciente vea agravado su cuadro clínico, se encuentra cerca de un hospital y pueda ser trasladado de forma inmediata

- Cobertura Cesac: 15%. Entendiendo que en algunos Cesacs se realizan test a casos sospechosos, en caso que de positivo, es importante que el paciente se traslade caminando hacia el centro de salud, con el fin de evitar que utilice el transporte público y contagie a otros pasajeros. Por ello, nos interesa que el Cesac esté cerca del centro de salud.

- Promedio del precio por metro2 por barrio: 10%. Considerando que el Gobierno de la Ciudad no cuenta con muchos fondos, entendemos que esta variable nos va a permitir seleccionar la manzana que más se ajuste al presupuesto


```{r}
indice01 <- manzanas %>%
            mutate(I1=cat_densidad*0.1+cat_distanciasubte*0.1+cat_distanciametrobus*0.1+cat_distanciavenida*0.1+cat_cobhospitales*0.35+cat_cobcesac*0.15+cat_promediom2*0.1,
                   I1=ifelse(I1>quantile(I1,probs = 0.9,na.rm = TRUE),TRUE,FALSE))
```

*Filtramos*

```{r}
indice01 <- filter(indice01, I1=="TRUE")
```

A continuación graficaremos las manzanas que cumplen con la ponderación del Indice01

```{r fig.height=10, fig.width=10}
ggplot() +
  geom_sf(data=manzanas, aes (fill= ""), color="grey60") +
  geom_sf(data=indice01, aes (fill="Manzanas que cumplen condición 01"), alpha=0.75) +
  geom_sf(data=hoteles, aes (color="Hoteles"), size=1)+
  geom_sf(data=hospitales, aes (color="Hospitales"), size=1)+
  scale_fill_manual(values = c("Manzanas que cumplen condición 01"= "hotpink4", "NA"="white"),name = NULL, guide = guide_legend(override.aes = list(linetype = "blank", shape = NA)))+
  scale_colour_manual(values = c(Hoteles="olivedrab4", Hospitales="orange"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  theme_minimal() +
  coord_sf(datum=NA) +
  labs(title="Índice 01",
       subtitle="Manzanas",
       caption= "Fuente: BA DATA y Properati") +
  theme_void()
```

Este mapa nos muestra en color púrpura las manzanas en las cuales sería conveniente colocar los centros de salud en base a las siguientes variables y la ponderación anteriormente mencionada: densidad poblacional, distancia subte, distancia metrobus, distancia avenidas, cobertura hospital, cobertura Csac y precio promedio de m2 de unidades en alquiler por barrio. 

Ahora bien, en verde, se muestran la distribución de alojamientos para ver su ubicación en relación a las manzanas selectas.

De la misma manera, se visualiza en naranja, los hospitales.

Considerando que un hotel puede que no se encuentre justo en la manzana selecta, pero si cerca, (Cerca =radio de 100m) decidimos conocer la cobertura de los hoteles (cobertura=100m), para que queden las manzanas con hoteles cercanos. Para ello:

1º Calculamos nuevamente el centroide de nuestras manzanas selectas.

```{r}
manzanasI1centroide <- st_centroid(indice01)
```

2º Calculamos la cobertura de nuetras manzanas.

```{r}
radiomanzanaI1 <- manzanasI1centroide %>% 
    st_buffer(dist = 100) %>%
    summarise(cobertura=TRUE)
```

3º Unimos al dataset de hoteles la cobertura.

```{r}
hotelesI1 <-st_join(hoteles, radiomanzanaI1)
```

4º Nos quedamos solamente con aquellos hoteles que se encuentren dentro del radio de nuestras manzanas selectas.

```{r}
hotelesI1<- filter(hotelesI1, cobertura=="TRUE")
```

Ahora graficaremos los hoteles que se encuentran dentro de las manzanas selectas.

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, aes (fill=""), color="grey60") +
  geom_sf(data=hotelesI1, aes (color="Hoteles"))+
  scale_fill_manual(values = c("NA"="white"),name = NULL, guide = guide_legend(override.aes = list(linetype = "blank", shape = NA)))+
  scale_colour_manual(values = c(Hoteles="olivedrab4"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  labs(title="Hoteles ubicados en las manzanas selectas a partir del Indice 01",
       subtitle="Ciudad Autónoma de Buenos Aires",
       caption= "Fuente: BA DATA y Properati")+
  theme_void()
```

En el gráfico anterior se observa la localización de los hoteles que están ubicados en las manzanas seleccionadas según el Indice 01.

Ahora bien, entendiendo que al momento de realizar el Indice 01, algunas variables eran dicotómicas (ej: hoteles, Cesacs) y otras no (ej: Metrobus, Subte), ahora haremos un Indice 02 en el que todas las variables serán dicotómicas, para que la ponderación se realice sobre igual cantidad de categorias de cada variable. Vale aclarar que mantendremos las mismas ponderaciones (Indice02)
Para ellos se considerará la madiana (quiebresmediana)


```{r}
quiebresmediana <- c(0,0.5,1)
```

```{r}
manzanas02 <- manzanas %>% 
            mutate(cat_densidad=cut(densidadPob,breaks = quantile(densidadPob,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciasubte=cut(-distanciasubte,breaks =quantile(-distanciasubte,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciametrobus=cut(-distanciametrobus,breaks = quantile(-distanciametrobus,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_promediom2=cut(-promediometro2,breaks = quantile(-promediometro2,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciavenida=cut(-distanciaavenida,breaks = quantile(-distanciaavenida,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE))
```

```{r}
manzanas02 <- manzanas02 %>% 
   mutate(cat_densidad=as.numeric(cat_densidad),
          cat_distanciasubte=as.numeric(cat_distanciasubte),
          cat_distanciametrobus=as.numeric(cat_distanciametrobus),
          cat_distanciavenida=as.numeric(cat_distanciavenida),
          cat_promediom2=as.numeric(cat_promediom2))
```

```{r}
indice02 <- manzanas02 %>%
            mutate(I1=cat_densidad*0.1+cat_distanciasubte*0.1+cat_distanciametrobus*0.1+cat_distanciavenida*0.1+cat_cobhospitales*0.35+cat_cobcesac*0.15+cat_promediom2*0.1,
                   I1=ifelse(I1>quantile(I1,probs = 0.9,na.rm = TRUE),TRUE,FALSE))
```

```{r}
indice02 <- filter(indice02, I1=="TRUE")
```

A continuación se graficarán las manzanas (bordó) que responden a la ponderación del Indice02, los hospitales (celeste) los hoteles (verde) de la Ciudad de Buenos Aires.
A partir de analizar las observaciones que arroja este dataset (indice02= 997 observaciones), vemos que son menos manzanas que las del Indice01 (1147 0bservaciones).

```{r fig.height=10, fig.width=10}
ggplot() +
  geom_sf(data=manzanas, color="grey60") +
  geom_sf(data=indice02, fill="hotpink4", alpha=0.75) +
  geom_sf(data=hoteles, color="olivedrab4", size=1)+
  geom_sf(data=hospitales, color="turquoise3")+
  theme_minimal() +
  coord_sf(datum=NA) +
  labs(title="Índice 02",
     subtitle="Manzanas",
      caption= "Fuente: BA DATA y Properati")+
  theme_void()
```

A partir de esta información, buscaremos los hoteles que se encuentren en estas manzanas, teniendo en cuenta en el dataset "hoteles"
----------------------------------------------------------------------------------------------------------

Podemos ver que las manzanas que arroja nuestro índice ha variado levemente. A partir de aquí, avanzaremos sobre la identificación de los hoteles que se encuentran dentro de las mismas.

```{r}
manzanasI2centroide <- st_centroid(indice02)
```

```{r}
radiomanzanaI2 <- manzanasI2centroide %>% 
    st_buffer(dist = 100) %>%
    summarise(cobertura=TRUE)
```

```{r}
hotelesI2 <-st_join(hoteles, radiomanzanaI2)
```

```{r}
hotelesI2<- filter(hotelesI2, cobertura=="TRUE")
```

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, aes(color="")) +
  geom_sf(data=hotelesI2, aes(color="Hoteles Indice 2"), show.legend =)+
  scale_colour_manual(values = c("NA"= "grey60", "Hoteles Indice 2" ="olivedrab4"),name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
  labs(title="Hoteles ubicados en las manzanas selectas a partir del Indice 02",
       subtitle="Ciudad Autónoma de Buenos Aires",
       caption= "Fuente: BA DATA y Properati")+
  theme_void()
```

Al igual con el gráfico de manzanas, los cambios entre hoteles seleccionados son leves. Para ver estás diferencias, graficaremos, primero, las manzanas, y , segundo, los hoteles de ambos índices.

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, aes(fill="NA"))+
  geom_sf(data=indice1, aes(fill="Hoteles Indice 01", alpha=0.5, size=3), show_legend=)+
  geom_sf(data=indice2, aes(fill ="Hoteles Indice 02", alpha=0.5, size=3),show_legend=)+
  scale_fill_manual(values = c("NA"= "white", "Manzanas Indice 01" = "blue", "Manzanas Indice 02"="red"),name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
    labs(title="Manzanas selectas de los Indices 01 y  02",
       subtitle="Ciudad Autónoma de Buenos Aires",
       caption= "Fuente: BA DATA y Properati")+
  theme_void()
```

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, aes(fill="NA"))+
  geom_sf(data=hotelesI1, aes(color="Hoteles Indice 01", alpha=0.5, size=3), show_legend=)+
  geom_sf(data=hotelesI2, aes(color ="Hoteles Indice 02", alpha=0.5, size=3),show_legend=)+
  scale_colour_manual(values = c("NA"= "white", "Hoteles Indice 01" = "blue", "Hoteles Indice 02"="red"),name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
    labs(title="Manzanas selectas a partir de la combinación entre Indice 01 y  02",
       subtitle="Ciudad Autónoma de Buenos Aires",
       caption= "Fuente: BA DATA y Properati")+
  theme_void()
```


```{r}
indice01 <- select(indice01, -(cat_densidad:cat_cobcesac))
```

```{r}
indice02 <- select(indice02, -(cat_densidad:cat_cobcesac))
```

```{r}
manzanasindices <- st_intersection(indice01,indice02)
```
```{r}
hotelesindices <- st_intersection(hotelesI1,hotelesI2)
```

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, aes(fill="")) +
  geom_sf(data=manzanasindices, aes(fill="Manzana Indice"), show.legend = )+
  geom_sf(data=hotelesindices, aes(color = "Hoteles Indice"), show.legend ="point")+
  scale_fill_manual(values = c("NA"= "white", "Manzana Indice" = "hotpink4"),name =NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
  scale_colour_manual(values=c("Hoteles Indice"="lightblue4"), name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
  labs(title="Hoteles ubicados en las manzanas selectas a partir de la combinación entre Indice 01 y  02",
       subtitle="Ciudad Autónoma de Buenos Aires",
       caption= "Fuente: BA DATA y Properati")+
  theme_void()
```
