---
title: "Instrumentos de Análisis Urbano I"
author: "Florencia Kihara,  Victoria Marco y Santiago Soubie"
date: "11/6/2021"
output: html_document
---

# **TRABAJO PRÁCTICO FINAL**

*INTEGRANTES*
  - Florencia Kihara
  - Victoria Marco
  - Santiago Soubie

**Consigna**

*Debido a la pandemia del COVID-19, el Gobierno de la Ciudad de Buenos Aires tomó la decisión de reutilizar la capacidad hotelera preexistente para poder mejorar la capacidad de atención sanitaria para la población. Sin embargo, encontrar las ubicaciones óptimas no es una tarea trivial.*

*Por un lado, el presupuesto con el que cuenta el GCBA es limitado. Por otro lado, la zona donde estén estos nuevos centros de atención de pacientes va a depender de distintos factores como la accesibilidad y la densidad poblacional.*

*El objetivo de este trabajo es poder indicar las manzanas de la Ciudad de Buenos Aires de mayor viabilidad para el alquiler de algún inmueble en base a los siguientes criterios:*

*● Costo promedio de alquiler*

*● Métricas de accesibilidad (cercanía con avenidas, cercanía con una estación de subte y cualquier otra variable que les pueda parecer útil, tiempo de viaje, en minutos caminando o en auto, desde distintos puntos de la Ciudad)*

*● Densidad poblacional*

Antes de arrancar con nuestro trabajo, cargamos las librerías que vamos a utilizar a lo largo del proyecto.

```{r}
library(tidyverse)
library(sf)
```
```{r}
options(scipen=100)
```

## **PRIMERA PARTE: PREPARANDO NUESTROS DATASETS**

Nuestro trabajo consiste en identificar las manzanas de mayor viabilidad para el alquiler de algún inmueble que permita mejorar la capacidad de atención sanitaria de la Ciudad de Buenos Aires (CABA). Particularmente, creemos que estos inmuebles deben ser destinados a acoger a los pacientes de COVID-19 con sintomologías leves. Con este fin, utilizaremos distitos datasets (espaciales y no). Estos comprenden:

- Aquellos vinculados a la organización territorial de la CABA.

```{r}
barriosCABA <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/mapaCABA.geojson") 
```

```{r}
radiosCensales <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/radioscensales.geojson")
```

```{r}
manzanas <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/manzanas.geojson")
```

- Aquellos relacionados a la planta del transporte.

```{r}
calles <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/callejero.geojson")
```

```{r}
subte <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/estacionsubte.geojson")
```

```{r}
metrobus <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/metrobus.geojson",
                    stringsAsFactors=TRUE )
```

```{r}
summary(metrobus$METROBUS)
```

*Si observamos dentro del dataset "metrobus", veremos algunas paradas por fuera de la CABA. Vamos a quitarlas*

```{r}
metrobus <- filter(metrobus, METROBUS!="Metrobus Norte - Av Maipú (provincia)")
```

- Aquellos ligados a infraestructuras de salud

```{r}
hospitales <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/hospitales.geojson")
```

```{r}
csac <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/csac.geojson")
```

- Aquel que contiene los alojamientos de la CABA

```{r}
hoteles <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/alojamientos.geojson")
```

*Graficamos*

```{r fig.height=10, fig.width=10}
ggplot() + 
  geom_sf(data=barriosCABA, aes (fill=""), color="gray60")+
  geom_sf(data=hoteles, aes(color="Hoteles"), show.legend ="point", size=2, alpha=0.75)+
  geom_sf(data=hospitales,aes(color="Hospitales"), show.legend ="point", size=2, alpha=0.75)+
  geom_sf(data=csac, aes(color="Csacs"), show.legend = "point", size=2, alpha=0.75)+
  geom_sf(data=subte,aes(color="Subte"), show.legend ="point", size=2, alpha=0.75)+
  geom_sf(data = metrobus, aes(color="Metrobús"), show.legend = "point", size=2, alpha=0.75)+
  scale_colour_manual(values= c("Hoteles"="olivedrab4","Hospitales"="hotpink4","Subte"="salmon", "Csacs"="lightblue4", "Metrobús"="gold2"), name="Referencias",
                    guide=guide_legend(override.aes=list(linetype="blank")))+
  scale_fill_manual(values= c("NA"="white"),name=NULL,
                  guide=guide_legend(override.aes=list(linetype="blank",shape=NA)))+
  labs(title = "Infraestructuras de la Ciuad Autónoma de Buenos Aires",
      caption = "Fuente: BA DATA")+
  theme_void()+
  theme(plot.title = element_text(size = 16),
        plot.caption = element_text(size = 10))
```

- Aquel que posee el precio de las propiedades en alquiler.

```{r}
properati <- read.csv("C:/Users/Santi/Desktop/Santi/Ciencia de Datos/Instrumento de Analisis Urbano/TP/Datasets/properati.csv",
                      stringsAsFactors = TRUE,
                      encoding = "UTF-8")
```

*Al ser tantos registros, para asegurarnos de que la base de datos solo contenga valores únicos, aplicaremos la función unique*

```{r}
properati <- unique(properati)
```

Empezaremos por trabajar sobre este último dataset debido a que es necesario intervenir el mismo para poder obtener la información necesaria para nuestro proyecto.

1º. Extraemos el año de la columna "created_on" para poder filtrar los casos del año 2021.
2º. Seleccionamos aquellos registros donde existe información precisa para la CABA.
3º. Pesificamos los precios de los alquileres en dolares al valor de referencia de $150 a fin de homogeneizar la unidad de valor para todos los regitros. 
4º. Eliminamos las columnas que no serán de utilidad para nuestro trabajo.

```{r}
properati2021 <- properati %>% 
  separate(created_on, c("ano", "mes", "dia"), sep = "-") %>% 
  filter(ano=="2021" & l2=="Capital Federal" & price!="NA" & currency!="") %>% 
  mutate(precio=ifelse(currency=="USD", price*150, price*1)) %>% 
  rename(barrios=l3) %>% 
  select(-start_date, -end_date, -mes, -dia, -l4, -l5, -l6, -price, -currency)
```

Teniendo en cuenta que el objetivo final del trabajo es definir dónde se deberían instalar los centros de atención a pacientes Covid positivos leves, optamos por quedarnos unicamente con los registros correspondientes a "Departamentos" y "Oficinas", ya que consideramos que son el tipo de producto que permite albergar a muchas personas en un mismo edificio, procurando la mayor eficiencia posible del espacio y los recursos humanos para la atención de los pacientes.

```{r}
properati2021 <- filter(properati2021, property_type %in% c("Departamento", "Oficina"))
```

Ahora calcularemos el precio del metro cuadrado (m2). Para ello:

1º. Quitaremos los casos que no cuenten con ninguna superficie medible (total y/o cubierta).
2º. Crearemos una columna que contenga la superficie total, o, en detrimento, la cubierta.
3º. Calcularemos el precio del m2.
4º. Quitaremos los casos menores a 32 m2 (el estándar mínimo que debe tener una unidad funcional de acuerdo con el Nuevo Código de Edificación de la CABA) y mayores a 75000m2 (a una escala superior, pierde sentido el motivo por el cual se optó quedarse unicamente con los registros pertenenecientes a departamentos y oficinas).

```{r}
properati2021 <- properati2021 %>% 
  filter(!(surface_covered=="NA" & surface_total=="NA")) %>% 
  mutate(superficie=ifelse(is.na(surface_total), surface_covered, surface_total),
         metro2=precio/superficie,
         metro2=round(metro2,0)) %>% 
  filter(superficie>=32 & superficie<=7500)
```

Luego, queremos clasificar los alquileres en categorías según su valor. Entonces:

1º Creamos el vector que va a establecer los quiebres (en quintiles).

```{r}
quiebres <- c(0,0.2,0.4,0.6,0.8,1)
```

2º Clasificamos los valores de acuerdo a categorías. 

```{r}
properati2021 <- mutate(properati2021, catmetro2=cut(metro2,breaks = quantile(metro2,quiebres,na.rm = TRUE, dig.lab = 5),include.lowest = TRUE))
```

*Modificamos las etiquetas para que sea más simple comprenderlas*

```{r}
properati2021 <- mutate(properati2021, catmetro2=as.numeric(catmetro2),
                        catmetro2 = recode(catmetro2, "1"="Muy bajo", "2"="Bajo", "3"="Medio", "4"="Alto", "5"="Muy alto"))
```

Veamos que tenemos hasta el momento. Analicemos los valores del m2 de acuerdo a las dimensiones de los inmuebles. Para ello, primero clasifiquemos a los mismos en categorías de acuerdo a su tamaño. Luego, graficaremos.

```{r}
properati2021 <- mutate(properati2021, superficiecat=ifelse(superficie %in% 32:55, "Chico",
                                                     ifelse(superficie %in% 56:75, "Mediano",
                                                     ifelse(superficie %in% 76:150, "Grande", "Muy grande"))))
```

Comenzamos considerando unidades desde 32m2, medida mínima para unidad funcional que permite el Nuevo Código de Edificación de la CABA, hasta 55m2, que se podría considerar un 2 ambientes grande. Luego, desde la óptica del mercado inmobiliario, las unidades de hasta 75m2 son consideradas medianas, y más allá de dicha superficie, son grandes y muy grandes.

```{r fig.height=5, fig.width=10}
properati2021 <- mutate(properati2021, superficiecat=factor(superficiecat, levels = c ("Chico", "Mediano", "Grande", "Muy grande")))

ggplot(data = properati2021) +
  geom_boxplot(aes(x=superficiecat, y=metro2), show.legend = FALSE)+
  scale_y_continuous(limit = c(0, 400000), breaks = seq(0, 400000, 100000))+
  labs(title ="Oficinas y departamentos en alquiler de la Ciudad Autónoma de Buenos Aires", 
       caption = "Fuente: Properati",
       x= "Tamaño",
       y= "Valor alquiler (m2)")+
  theme_light()
```

A partir de este boxplot, podemos ver que valores extremos sesgan nuestra muestra. Por este motivo, el siguiente paso será quitar todos aquellos casos en los que el valor del m2 supere los 50.000 pesos.

```{r}
properati2021 <- filter(properati2021, metro2<50000)
```

*Graficamos nuevamente*

```{r fig.height=5, fig.width=10}
ggplot(data = properati2021) +
  geom_boxplot(aes(x=superficiecat, y=metro2), show.legend = FALSE)+
  scale_y_continuous(limit = c(0, 10000), breaks = seq(0, 10000, 2000))+
  labs(title ="Oficinas y departamentos en alquiler de la Ciudad Autónoma de Buenos Aires", 
       caption = "Fuente: Properati",
       x= "Tamaño",
       y= "Valor alquiler (m2)")+
  theme_light()
```

A través de este nuevo boxplot, podemos comprobar que continuan existiendo outliers, pero su magnitud no es tan extrema (comparativamente con los casos ya borrados), y, por lo tanto, no serán eliminados. 

Por último, procederemos a componer un mapa que nos permita visualizar la ubicación de las unidades de nuestro dataset a fin de poder identificar las zonas más significativas para nuestro análisis. Con este fin:

1º. Quitaremos todos los valores que no puedan ser ubicados en el mapa.

```{r}
properati2021 <- filter(properati2021, !(lon=="NA" & lat=="NA"))
```

2º Transformaremos nuestro dataset en uno espacial.

```{r}
properati2021 <- st_as_sf(properati2021,
                           coords = c("lon","lat"),
                           crs = 4326)
```

*Graficamos para ver nuestro resultado hasta el momento*

```{r fig.width=10, fig.height=10}
properati2021 <- mutate(properati2021, catmetro2=factor(catmetro2, levels = c ("Muy bajo", "Bajo", "Medio", "Alto", "Muy alto")))

ggplot()+
  geom_sf(data=barriosCABA, fill="grey96") +
  geom_sf(data=properati2021, aes(color=catmetro2))+
  scale_color_viridis_d()+
  labs(title ="Oficinas y departamentos en alquiler en la Ciudad Autónoma de Buenos Aires", 
       caption = "Fuente: Properati",
       color="Valor alquiler (m2)")+
  theme_void()+
  theme(plot.title = element_text(size = 16),
        plot.caption = element_text(size = 10))
```

3º Como podemos observar en nuestro dataset, la variable "barrios" contiene más barrios que los que son oficialmente reconocidos. Para poder asignar los registros de forma precisa, unimos nuestro dataset con el dataset "barriosCABA".

```{r}
properati2021<- st_join(barriosCABA,properati2021)
```

```{r}
filter(properati2021, barrio=="VERSALLES") 
```

*Gracias a este último paso, podemos ver que nos valores extremos de Versalles, en realidad, se encuentran mal geolocalizados. Vamos a quitarlos*

```{r}
properati2021 <- filter(properati2021, !(barrio=="VERSALLES" & barrios=="Catalinas"))
```

4º Agrupamos los registros y calculamos la media del m2 por barrio.

```{r}
properati2021barrios <- properati2021 %>% 
  group_by(barrio) %>% 
  summarise(promediometro2=mean(metro2)) %>% 
  mutate(promediometro2=round(promediometro2, 2))
```

*Graficamos*

```{r fig.width=10, fig.height=10}
ggplot() +
  geom_sf(data=barriosCABA)+
  geom_sf (data=properati2021barrios, aes(fill=promediometro2)) +
  labs(title ="Alquiler promedio", 
       subtitle = "Por barrio de la Ciudad Autónoma de Buenos Aires",
       caption = "Fuente: Properati",
       fill="Valor alquiler (m2)")+
  scale_fill_viridis_c(na.value = "transparent",
                           breaks=c(0,1000,2000,3000),
                           limits=c(0,3000))+
  theme_void()+
  theme(plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 10))
```

Por último, unimos nuestro dataset al de radios censales que contiene la información por barrio. De estos últimos, aquellos que aparecen sombreados en gris son los que no contienen ningún registro en el dataset Properati.

```{r}
properati2021barrios <- properati2021barrios %>% 
  st_set_geometry(NULL) %>% 
  rename(BARRIO=barrio)

radiosCensales <- left_join(radiosCensales, properati2021barrios, by="BARRIO")
```

## **SEGUNDA PARTE: SELECCIONANDO LA MANZANA IDEAL**

Previo a seleccionar los inmuebles, *ergo*, los hoteles con la mejor ubicación para mejorar la capacidad de atención sanitaria de la CABA, es necesario identificar las manzanas con mayor viabilidad para el alquiler de los mismos. Para ello, las mismas deben cumplir con ciertos requisitos que desarrollaremos a lo largo de esta sección.

Puesto que trabajaremos con distintos datasets espaciales, homogeneizaremos los sistemas de coordenadas. Como referencia, utilizaremos el sitema de coordenadas que emplea el GCBA.

```{r}
hospitales <- st_transform(hospitales, crs="+proj=tmerc +lat_0=-34.6297166 +lon_0=-58.4627 +k=1 +x_0=100000 +y_0=100000 +ellps=intl +units=m +no_defs")
csac <- st_transform(csac, crs=st_crs(hospitales))
metrobus <- st_transform(metrobus, crs = st_crs(hospitales))
subte <- st_transform(subte, crs = st_crs(hospitales))
hoteles <- st_transform(hoteles, crs=st_crs(hospitales))
barriosCABA <- st_transform(barriosCABA, crs = st_crs(hospitales))
manzanas <- st_transform(manzanas, crs = st_crs(hospitales))
calles <- st_transform(calles, crs = st_crs(hospitales))
radiosCensales <- st_transform(radiosCensales, crs = st_crs(hospitales))
```

Como primer parámetro a cumplir por nuestras manzanas, queremos que aquellas que elijamos se encuentren, como mucho, a 1000 mts de un hospitales públicos y a 1500 mts de un Csac. Para obtener este dato, primero tenemos que calcular la cobertura de estas infraestructuras de salud.

```{r}
coberturaHospitales <- hospitales %>% 
    st_buffer(dist = 1000) %>%
    summarise(cobertura=TRUE)
```

```{r}
coberturacsac <- csac %>% 
    st_buffer(dist = 1500) %>%
    summarise(cobertura=TRUE)
```

La cercanías a centros de salud permitirá un rápido acceso en circunstancias en la que los casos se agraven. Este punto lo retomaremos más adelate. Por ahora, solo graficamos.

scale_colour_manual(values = c("Centroide de Manzana" = "grey60", "Avenidas"="mediumvioletred", "Subte"="royalblue4", "Metrobus"="orange2"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=barriosCABA, fill="NA", color="gray60")+
  geom_sf(data=coberturacsac, alpha=0.5, aes(fill="Cobertura Cesac"), show.legend = TRUE)+
  geom_sf(data=coberturaHospitales, alpha=0.5,aes(fill="Cobertura Hospitales"), show.legend = TRUE )+
  geom_sf(data=hoteles, size=1.5, aes(color="Hoteles"))+
  scale_fill_manual(values= c("Cobertura Hospitales"="olivedrab4","Cobertura Cesac"="lightblue4"), name=NULL , guide=guide_legend(override.aes=list(linetype="blank", shape=NA)))+
  scale_colour_manual(values= c("Hoteles"="black"), name = "Referencias",  guide = guide_legend(override.aes = list(linetype = "blank")))+
   labs(title = "Cobertura de los centros de salud",
       caption = "Fuente: BA DATA",
       fill="")+
  theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.1, face = "bold"),
        plot.caption = element_text(size=10))
```

Realacionado con el punto anterior, otra de las condiciones que debe cumplir nuestra manzana es que sea de fácil acceso. En este sentido, las mismas deben encontrarse a una distancia prudencial de las estaciones de subte, de metrobus y las avenidas. Con ello en mente:

1º. Como un extremo de una manzana puede estar más cerca de una ubicación que otro y, a su vez, dado que una manzana puede poseer una forma irrregular, calcularemos la distancia desde el centro. Por este motivo, nuestro primer paso será extraer los centros de manzanas.

```{r}
manzanacentroide <- st_centroid(manzanas)
```

2º Hacemos un dataset que solo contenga las avenidas de CABA.

```{r}
avenidas <- filter(calles, tipo_c=="AVENIDA")
```

*Graficamos para ver los centroides de manzana*

```{r fig.height=10, fig.width=10}
ggplot()+ 
  geom_sf(data = manzanas, fill = NA, size = 0.1, color="gray60") +
  geom_sf(data = manzanacentroide, aes (color = "Centroide de Manzana"), show.legend="point", size=0.1)+
  geom_sf(data = avenidas, aes (color = "Avenidas"), show.legend =)+
  geom_sf(data = subte, aes(color = "Estación de Subte"), show.legend="point", size=2)+
  geom_sf(data = metrobus, aes (color = "Parada de Metrobus"), show.legend="point", size=2)+
  scale_colour_manual(values = c("Centroide de Manzana" = "grey60", "Avenidas"="mediumvioletred", "Estación de Subte"="royalblue4", "Parada de Metrobus"="orange2"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  labs(title = "Centros de manzana",
       subtitle = "En relación al sistema vial",
       caption = "Fuente: BA DATA")+
  theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.1, face = "bold"),
        plot.caption = element_text(size=10),
        plot.subtitle = element_text(size = 12, hjust = 0.1))
```

3º Calculamos la distancia desde los centroides de manzana a los distintos puntos de transporte.

```{r}
distanciavenida <- st_distance(manzanacentroide, avenidas)

distanciasubte <- st_distance(manzanacentroide, subte)

distanciametrobus <- st_distance(manzanacentroide, metrobus)
```

4º Como el paso anterior nos devolvió todas las distacias posibles desde nuestros centroides de  manzana a todos los puntos de transporte, solo nos vamos a quedar con las de menor tamaño.

```{r}
avenidacercana <- apply(distanciavenida,1,function(x) min(x))
```

```{r}
subtecercano <- apply(distanciasubte,1, function(x) min(x))
metrobuscercano <- apply(distanciametrobus,1, function(x) min(x))
```

*Redondeamos los valores*

```{r}
avenidacercana <- round(avenidacercana, 0)
subtecercano <- round(subtecercano, 0)
metrobuscercano <- round(metrobuscercano, 0)
```

5º Agregamos las distancias al dataset de manzanas

```{r}
manzanas <- mutate(manzanas, distanciaavenida=avenidacercana,
                   distanciasubte=subtecercano,
                   distanciametrobus=metrobuscercano)
```

En resumen, hemos decidido considerar las distancias a avenidas, a la red de metrobus y a la red de subte para garantizarla  accesibilidad en diversos medios de transportes

A continuación graficaremos las manzanas (Manzanas ideales) que cumplen con las condiciones que llamaremos "Condición 00":

-  Que esté a 500m de una parada de Metrobus,

-  Que esté a 500m de una estación de subte,

-  Que esté a 200m de una avenida.

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, fill="NA", color="gray60")+
  geom_sf(data=filter(manzanas, distanciametrobus<=500 & distanciasubte<=500 & distanciaavenida<=200), aes (fill="Manzanas ideales"))+
  scale_fill_manual(values = c("Manzanas ideales"="olivedrab"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
  labs(title = "Manzanas ideales", 
       subtitle= "Según cercanía a las avenidas y las redes de Metrobús y de Subte",
       caption = "Fuente: BA DATA")+
  theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.055, vjust = 0.1, face = "bold"),
        plot.caption = element_text(size=10),
        plot.subtitle = element_text(size = 12, hjust = 0.1))
```

Retomemos la cuestión de la cobertura de los hospitales y Cesacs.

Nosotros solo nos interesa quedarnos con aquellas manzanas que se encuentren a menos de 1000 mts de los hospitales, y a 1500 mts de los Cesacs. Para averguar cuales son:

1º Unimos el dataset de centroides de manzana con los de cobertura de hospitales y Cesacs. 

```{r}
manzanacentroide <- st_join(manzanacentroide, coberturaHospitales)
manzanacentroide <- st_join(manzanacentroide, coberturacsac)
```

*Renombramos las columnas*

```{r}
manzanacentroide <- rename(manzanacentroide, "cobhospitales"=cobertura.x,
                           "cobcesac"=cobertura.y)
```

*Graficamos*

```{r fig.height=10, fig.width=10}
manzanacentroideCobSalud <- filter(manzanacentroide, cobhospitales=="TRUE" & cobcesac=="TRUE")
manzanasCobSalud <- st_join(manzanas, manzanacentroideCobSalud)
manzanasCobSalud <- filter(manzanasCobSalud, cobhospitales=="TRUE" & cobcesac=="TRUE")

ggplot()+
  geom_sf(data = manzanas, fill=NA, color="gray60")+
  geom_sf(data = manzanasCobSalud, aes (fill="Manzanas ideales"), show.legend =)+
   scale_fill_manual(values = c("Manzanas ideales"= "lightblue2"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  labs(title = "Manzanas ideales", 
       subtitle= "Según cobertura de centros de salud",
       caption = "Fuente: BA DATA")+
  theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.055, vjust = 0.1, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.0625))
```

Otro factor que tendremos en cuenta es el de densidad poblacional.

Nuestro objetivo es seleccionar aquellas manzanas donde haya una gran cantidad personas a la redonda a fin de que los alojamientos estén cerca de donde más se los necesita. Para calcular la misma: 

1º Creamos una columna que contenga la población por km2 de cada radio censal.

```{r}
radiosCensales <- mutate(radiosCensales, densidadPob=round(POBLACION/AREA_KM2, 2))
```

*Graficamos*

```{r fig.height=10, fig.width=10}
ggplot() +
  geom_sf(data = radiosCensales, aes(fill=densidadPob))+
  labs(title = "Densidad poblacional en la Ciudad Autónoma de Buenos Aires ",
       subtitle = "Por manzana",
       fill= "Habitantes por km2",
       caption="Fuente: BA DATA")+
  scale_fill_viridis_c()+
  theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.055, vjust = 0.1, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 14, hjust = 0.0155))
```

2º Unimos el dataset de los radios censales al de manzanas centroides.

```{r}
manzanacentroide <- st_join(manzanacentroide,radiosCensales)
```

Una vez finalizados estos pasos, seleccionamos las columnas de interés del dataset manzanascentroide y las volcamos a nuestro dataset de manzanas.

```{r}
manzanacentroide <- manzanacentroide %>% 
                      as.data.frame() %>%
                      select(SM, cobhospitales, cobcesac, promediometro2, densidadPob)
manzanas <- left_join(manzanas, manzanacentroide, by="SM")
```

*Al unir nuestros datasets, vemos que se suman más casos de los que debería haber (12588 frente a 12520). Averiguamos si se generaron duplicados*

```{r}
duplicados <- duplicated(manzanas, incomparables = FALSE)
```

```{r}
summary(duplicados)
```

*Efectivamente, algunos registros fueron duplicados. Por ello, procederemos  a quedarnos solo con los valores únicos*

```{r}
manzanas <- unique(manzanas)
```

Ahora, creamos un dataset que cuente con las manzanas que cumplen con las siguientes condiciones:

- que posea cobertura de hospitales.

- que posea cobertura Cesacs.

- que posea una densidad poblacional mayor o igual que la media por manzana de la CABA (media = 27.477).

```{r}
radiosCensales %>% mutate(media=mean(densidadPob)) %>% select(media)
```


- que se encuentre a 500 mts o menos de una parada de metrobús.

- que se encuentre a 500 mts o menos de una estación de subte.

- que se encuentre a 200 mts o menos de una avenida.

- que la manzana esté dentro de un barrio donde el valor del m2 de las unidades en alquiler sea menor o igual a la media de la ciudad (media = 1205).

```{r}
properati2021 %>% filter(!(is.na(metro2))) %>% 
mutate(media = mean(metro2)) %>% 
select(media)
```

```{r}
manzanaselecta <- filter(manzanas, cobhospitales==TRUE & cobcesac==TRUE & densidadPob>=27477 & distanciametrobus<=500 & distanciasubte<=500 & distanciaavenida<=200 & promediometro2<=1205)
```

Ahora graficaremos las manzanas que cumplen con estas condiciones y la ubicación de los hoteles de la Ciudad.

```{r fig.height=10, fig.width=10}
ggplot()+geom_sf(data=manzanas, fill="NA", color="gray60", size=0.2)+
        geom_sf(data=manzanaselecta, aes(fill="Manzanas ideales"))+
        geom_sf(data=hoteles, aes (color="Hoteles"), size=1, show.legend = "point")+
  scale_colour_manual(values = c(Hoteles="hotpink4"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  scale_fill_manual(values = c("Manzanas ideales"= "turquoise"),name = NULL,
                    guide = guide_legend(override.aes = list(linetype = "blank", shape = NA))) +
   labs(title = "Manzanas ideales para la ubicación de un centros de alojamiento",
        subtitle = "Según criterios establecidos",
        caption="Fuente: BA DATA & Properati")+
        theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.1, vjust = 0.1, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 14, hjust = 0.032))
```

Al analizar el mapa, se puede observar que las manzanas que cumplen con las condiciones estipuladas son escasas. Esto va en detrimento de la escala que se quiere alcanzar para alivianar el sistema de salud. Por ello, es necesaria una nueva manera de abordar nuestras condiciones.

## **TERCERA PARTE: CONSTRUYENDO UN ÍNDICE**

Entendiendo que los parámetros que seleccionamos en este trabajo pueden ser valorados de distinta manera, hemos decidido construir un índice que pondere dichas variables.
 
Antes de avanzar en esta dirección, debemos realizar algunas operaciones sobre las variables previamente mencionadas.

1º Considerando los quiebres indicados con anterioridad, dividiremos las variables en quintiles para normalizar los valores

```{r}
manzanas <- manzanas %>% 
            mutate(cat_densidad=cut(densidadPob,breaks = quantile(densidadPob,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciasubte=cut(-distanciasubte,breaks = quantile(-distanciasubte,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciametrobus=cut(-distanciametrobus,breaks = quantile(-distanciametrobus,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_promediom2=cut(-promediometro2,breaks = quantile(-promediometro2,quiebres,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciavenida=cut(-distanciaavenida,breaks = quantile(-distanciaavenida,quiebres,na.rm = TRUE ),include.lowest = TRUE))
```

```{r}
manzanas<- mutate (manzanas, cobhospitales=ifelse(is.na(cobhospitales),"FALSE","TRUE"),
                   cobcesac=ifelse(is.na(cobcesac),"FALSE","TRUE"))
```

2º Luego, a cada categoría le asignaremos un valor numérico.

```{r}
manzanas <- manzanas %>% 
   mutate(cat_densidad=as.numeric(cat_densidad),
          cat_distanciasubte=as.numeric(cat_distanciasubte),
          cat_distanciametrobus=as.numeric(cat_distanciametrobus),
          cat_distanciavenida=as.numeric(cat_distanciavenida),
          cat_promediom2=as.numeric(cat_promediom2),
          cat_cobhospitales=ifelse(cobhospitales=="TRUE",2,1),
          cat_cobcesac=ifelse(cobcesac=="TRUE",2,1))
```

Ahora desarrollaremos el índice (Indice 01), considerando las siguientes ponderaciones sobre las variables:

- **Cobertura hospitales: 30%**. Que se encuentre en las inmediaciones de un hotel es el factor más relevante a tener en cuenta. Ello se debe a que, en el caso de que a un paciente vea agravado su cuadro clínico, se encuentre cerca de un hospital y pueda ser trasladado de forma inmediata.

- **Cobertura Cesac: 15%**. En la medida que los Cesacs realizan test a casos sospechosos, resulta valioso que, ante casos positivos, los paciente puedan ser trasladados en taxi o a pie a los centros de alojamiento.

-**Distancia avenidas: 15%**, con el fin de facilitar la accesibilidad a los centros de salud por parte de personal que atiende a los pacientes y las ambulancias.

- **Distancia subte: 10%**, con el fin de facilitar la accesibilidad a los centros de salud por parte de personal que atiende a los pacientes

- **Distancia Metrobus: 10%**, con el fin de facilitar la accesibilidad a los centros de salud por parte de personal que atiende a los pacientes.

- **Promedio del precio por metro2 por barrio: 10%**. Considerando que el Gobierno de la Ciudad cuenta con fondos limitamos, entendemos que esta variable nos va a permitir seleccionar la manzana que más se ajuste al presupuesto.

- **Densidad: 10%**. Nos permite identificar aquellas manzanas que aglutinan a una gran cantidad de personas, con el motivo de que los alojamientos permitan aliviar la presión existente.


```{r}
indice01 <- manzanas %>%
            mutate(I1=cat_densidad*0.1+cat_distanciasubte*0.1+cat_distanciametrobus*0.1+cat_distanciavenida*0.15+cat_cobhospitales*0.30+cat_cobcesac*0.15+cat_promediom2*0.1,
                   I1=ifelse(I1>quantile(I1,probs = 0.9,na.rm = TRUE),TRUE,FALSE))
```

*Filtramos*

```{r}
indice01 <- filter(indice01, I1=="TRUE")
```

*Graficamos aquellas manzanas que obtuvieron los valores más altos del índice01*

```{r fig.height=10, fig.width=10}
ggplot() +
  geom_sf(data=manzanas, fill= NA, color="grey60") +
  geom_sf(data=indice01, aes (fill="Manzanas selectas"), alpha=0.75) +
  geom_sf(data=hoteles, aes (color="Hoteles"))+
  scale_fill_manual(values = c("Manzanas selectas"= "turquoise"),name = NULL, guide = guide_legend(override.aes = list(linetype = "blank", shape = NA)))+
  scale_colour_manual(values = c(Hoteles="hotpink4"),name = "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  theme_void() +
  labs(title="Índice 01",
       subtitle="Manzanas",
       caption= "Fuente: BA DATA & Properati") +
  theme_void()+
   theme(plot.title = element_text(size = 20, hjust = 0.1, vjust = 0.2, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.1))
```

Este mapa nos muestra en color turquesa las manzanas en las cuales sería conveniente colocar los centros de alojamiento en base a las variables y la ponderación anteriormente estipuladas: densidad poblacional, distancia al subte, al metrobus y a las avenidas, cobertura de hospitales y Csacs, y el precio promedio de m2 de unidades en alquiler por barrio. 

Ahora bien, en violeta se muestra los alojamientos para ver su ubicación en relación a las manzanas selectas.

Considerando que un hotel puede que no se encuentre justo en la manzana selecta, pero si cerca (dentro de un radio de 100 m), decidimos conocer aquellos alojamientos que se ubican dentro de este rango. Para ello:

1º Calculamos nuevamente el centroide de nuestras manzanas selectas.

```{r}
manzanasI1centroide <- st_centroid(indice01)
```

2º Calculamos la cobertura de nuetras manzanas.

```{r}
radiomanzanaI1 <- manzanasI1centroide %>% 
    st_buffer(dist = 100) %>%
    summarise(cobertura=TRUE)
```

3º Unimos al dataset de hoteles la cobertura.

```{r}
hotelesI1 <-st_join(hoteles, radiomanzanaI1)
```

4º Nos quedamos solamente con aquellos hoteles que se encuentren dentro del radio de nuestras manzanas selectas.

```{r}
hotelesI1<- filter(hotelesI1, cobertura=="TRUE")
```

Ahora graficaremos los hoteles que caen dentro de las manzanas selectas.

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, fill=NA, color="grey60") +
  geom_sf(data=hotelesI1, aes (color="Hoteles"))+
  scale_colour_manual(values = c(Hoteles="hotpink4")) +
  labs(title="Hoteles ubicados en las manzanas selectas a partir del Indice 01",
       subtitle="Ciudad Autónoma de Buenos Aires",
       color="Referencias",
       caption= "Fuente: BA DATA & Properati")+
  theme_void()+
  theme(plot.caption = element_text(size=10))
```

En el gráfico anterior, se observa la localización de los hoteles que están ubicados en las manzanas seleccionadas según el Indice 01.

Ahora bien, entendiendo que al momento de realizar el Indice 01 se otorgaba un valor numérico a cada una de las categorías de las variables, y cada variable tenía un número diferente de categorías, haremos un nuevo índice (Indice 02) en el que todas las variables serán dicotómicas a fin de que la ponderación se realice sobre bases equivalentes. Con ello en mente:

1º Creamos un nuevo vector donde se establezcan la mediana.

```{r}
quiebresmediana <- c(0,0.5,1)
```

2º Repetimos el mismo proceso que realizamos al hacer el índice 01.

```{r}
manzanas02 <- manzanas %>% 
            mutate(cat_densidad=cut(densidadPob,breaks = quantile(densidadPob,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciasubte=cut(-distanciasubte,breaks =quantile(-distanciasubte,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciametrobus=cut(-distanciametrobus,breaks = quantile(-distanciametrobus,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_promediom2=cut(-promediometro2,breaks = quantile(-promediometro2,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE),
                   cat_distanciavenida=cut(-distanciaavenida,breaks = quantile(-distanciaavenida,quiebresmediana,na.rm = TRUE ),include.lowest = TRUE))
```

```{r}
manzanas02 <- manzanas02 %>% 
   mutate(cat_densidad=as.numeric(cat_densidad),
          cat_distanciasubte=as.numeric(cat_distanciasubte),
          cat_distanciametrobus=as.numeric(cat_distanciametrobus),
          cat_distanciavenida=as.numeric(cat_distanciavenida),
          cat_promediom2=as.numeric(cat_promediom2))
```

```{r}
indice02 <- manzanas02 %>%
            mutate(I2=cat_densidad*0.1+cat_distanciasubte*0.1+cat_distanciametrobus*0.1+cat_distanciavenida*0.15+cat_cobhospitales*0.30+cat_cobcesac*0.15+cat_promediom2*0.1,
                   I2=ifelse(I2>quantile(I2,probs = 0.9,na.rm = TRUE),TRUE,FALSE))
```

```{r}
indice02 <- filter(indice02, I2=="TRUE")
```

A primera vista, podemos observar que el numero de observaciones que arroja este dataset (997), es menor que el del índice 01 (1147).

*Graficamos*

```{r fig.height=10, fig.width=10}
ggplot() +
  geom_sf(data=manzanas, fill=NA, color="grey60") +
  geom_sf(data=indice02, aes (fill="Manzanas selectas"), alpha=0.75) +
  geom_sf(data=hoteles, aes (color="Hoteles"))+
  scale_fill_manual(values = c("Manzanas selectas"= "turquoise"), name= NULL, guide = guide_legend(override.aes = list(linetype = "blank", shape = NA)))+
  scale_colour_manual(values = c(Hoteles="hotpink4"), name= "Referencias",
                    guide = guide_legend(override.aes = list(linetype = "blank"))) +
  theme_void() +
  labs(title="Índice 02",
     subtitle="Manzanas",
      caption= "Fuente: BA DATA & Properati")+
  theme_void()+
    theme(plot.title = element_text(size = 20, hjust = 0.1, vjust = 0.2, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.1))
```

Podemos ver que la ubicación de las manzanas que arroja nuestro índice ha variado levemente. A partir de aquí, avanzaremos sobre la identificación de los hoteles que se encuentran dentro de las mismas.

```{r}
manzanasI2centroide <- st_centroid(indice02)
```

```{r}
radiomanzanaI2 <- manzanasI2centroide %>% 
    st_buffer(dist = 100) %>%
    summarise(cobertura=TRUE)
```

```{r}
hotelesI2 <-st_join(hoteles, radiomanzanaI2)
```

```{r}
hotelesI2<- filter(hotelesI2, cobertura=="TRUE")
```

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, fill=NA, color="grey60") +
  geom_sf(data=hotelesI2, aes(color="Hoteles"), show.legend =)+
  scale_colour_manual(values = c("Hoteles" ="hotpink4")) +
  labs(title="Hoteles ubicados en las manzanas selectas a partir del Índice 02",
       subtitle="Ciudad Autónoma de Buenos Aires",
       color= "Referencias",
       caption= "Fuente: BA DATA & Properati")+
  theme_void()+
theme(plot.title = element_text(size = 16, hjust = 0.1, vjust = 0.2, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.032))
```

Al igual con el gráfico de manzanas, los cambios entre hoteles seleccionados son leves. Para ver estás diferencias, graficaremos, primero, las manzanas, y, segundo, los hoteles de ambos índices.

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, fill="NA", color="grey60") +
  geom_sf(data=indice01, aes(fill="Manzanas Índice 01"), alpha=0.5)+
  geom_sf(data=indice02, aes(fill ="Manzanas Índice 02"), alpha=0.5)+
  scale_fill_manual(values = c("Manzanas Índice 01" = "blue", "Manzanas Índice 02"="red"))+
   labs(title="Manzanas selectas de los Indices 01 y 02",
       subtitle="Ciudad Autónoma de Buenos Aires",
       fill="Referencias",
       caption= "Fuente: BA DATA & Properati")+
  theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.1, vjust = 0.2, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.07))
```

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, fill="NA", color="grey60")+
  geom_sf(data=hotelesI1, aes(color="Hoteles Índice 01"), alpha=0.5, size=2)+
  geom_sf(data=hotelesI2, aes(color ="Hoteles Índice 02"), alpha=0.5, size=2)+
  scale_colour_manual(values = c("Hoteles Índice 01" = "blue", "Hoteles Índice 02"="red"))+
    labs(title="Hoteles del Índice 01 y el Índice 02",
       subtitle="Ciudad Autónoma de Buenos Aires",
       color="Referencias",
       caption= "Fuente: BA DATA y Properati")+
  theme_void()+
  theme(plot.title = element_text(size = 16, hjust = 0.083, vjust = 0.2, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.07))
```

Frente a esta situación, hemos decidido tomar ambos índices y quedarnos con las manzanas, *ergo*, los alojamientos comunes entre ambos. Para ello:

1º. Volvemos equilavelentes nuestros datasets.

```{r}
indice01 <- select(indice01, -(cat_densidad:cat_cobcesac))
```

```{r}
indice02 <- select(indice02, -(cat_densidad:cat_cobcesac))
```

2º. Unimos nuestros datasets.

```{r}
manzanasindices <- st_intersection(indice01,indice02)
```

```{r}
hotelesindices <- st_intersection(hotelesI1,hotelesI2)
```

*Graficamos*

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, fill=NA, color= "grey60") +
  geom_sf(data=manzanasindices, aes(fill="Manzana selecta"))+
  geom_sf(data=hotelesindices, aes(color = "Hotel selecto"))+
  scale_fill_manual(values = c("Manzana selecta" = "turquoise"), name=NULL)+
  scale_colour_manual(values=c("Hotel selecto"="hotpink4"), name="Referencia") +
  labs(title="¿Dónde podemos ubicar nuestros alojamientos para mejorar la capacidad de atención sanitaria de la CABA?",
       subtitle="Manzanas y hoteles",
       caption= "Fuente: BA DATA y Properati")+
  theme_void()+
    theme(plot.title = element_text(face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.07))
```
## **BONUS TRACK: DISTANCIA A LOS DETECTAR**

A partir del mapa anterior, se evidencian, marcados en color púrpura, los hoteles (hotel selecto) que cumplen con ambos índices (índice 01 e índice 02). Ahora bien, con el fin de poder hacer una selección más acotada, tanto de las manzanas como de los hoteles, incorporaremos el dato de la geolocalización de los centros DetectAr. Esto se hará tomando el DetectAR como centro de un polígono, cuyo radio será igual a la distancia que puede ser recorrida caminanado (transport mode: pedestrian) en 15 minutos. La importancia de que el traslado se realice caminando radica en que es la forma más segura que el paciente COVID positivo posee como alternativa de movilidad accesible, ya que de esta manera, tiene menor posibilidad de contagiar a terceros.

Para tal fin, realizaremos las siguientes operaciones: 

```{r}
detectAR <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/operativo-detectar.geojson")
```

```{r}
detectAR <- st_transform(detectAR, crs = st_crs(hotelesindices))
```

Con el fin de poder utilizar la herramienta "map" en los próximos pasos, habilitamos una nueva librería: hereR. 
```{r}
library(hereR)
```

```{r}
set_key("pcWH0YNYi1G1eqMvAM7fjHWMvqNOaKL6yprw1aMNCeU")
```

A continuación, graficamos en un mismo mapa, los centros DetectAR junto con las manzanas y los hoteles selectos (es decir, que cumplen con el índice 1 y el índice 2). 

```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, fill=NA, color= "grey60") +
  geom_sf(data=manzanasindices, aes(fill="Manzana selecta"))+
  geom_sf(data=hotelesindices, aes(color = "Hotel selecto"))+
  geom_sf(data=detectAR, aes(color="DetectAR"))+
  scale_fill_manual(values = c("Manzana selecta" = "turquoise"), name=NULL)+
  scale_colour_manual(values=c("Hotel selecto"="hotpink4", "DetectAR"="orange"), name="Referencia") +
  labs(title="Ubicación centros DetectAR",
       subtitle="con respecto a manzanas y hoteles selectos",
       caption= "Fuente: BA DATA & Properati")+
  theme_void()+
    theme(plot.title = element_text(hjust=0.07, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.07))
```

```{r}
isocronosdetectar <- map(1:nrow(detectAR),function(x) {isoline(detectAR[x,], transport_mode = "pedestrian",range_type = "time",range = 60*15)})
```

```{r}
isocronosdetectarjuntos <- do.call(rbind,isocronosdetectar)
```

```{r}
isocronosdetectarjuntospoligonos <-  st_union(isocronosdetectarjuntos)
```

```{r}
library(leaflet)
```

```{r}
leaflet(isocronosdetectarjuntospoligonos %>% st_transform(4326)) %>% 
  addTiles() %>% 
  addPolygons()
```
En el mapa anterior se visualizan los polígonos cuyo centro son los DetectAr y los radios son los 15 minutos de caminata. 

```{r}
isocronosdetectarjuntospoligonos <- st_transform(isocronosdetectarjuntospoligonos, crs="+proj=tmerc +lat_0=-34.6297166 +lon_0=-58.4627 +k=1 +x_0=100000 +y_0=100000 +ellps=intl +units=m +no_defs")
```

```{r}
isocronosdetectarjuntospoligonos <- st_as_sf(isocronosdetectarjuntospoligonos) %>% 
                                      mutate(cobertura=TRUE)
```


```{r}
st_crs(isocronosdetectarjuntospoligonos)
```
Habiendo obtenido los polígonos, los mapearemos junto con: 

- La totalidad de las manzanas de la Ciudad;

- Las manzanas selectas, que cumplen con las condiciones de los índices 01 y 02; y

- Los hoteles selectos, que cumplen con las condiciones de los índices 01 y 02. 

```{r}
manzanasdetectAR <- st_join(manzanas,st_as_sf(isocronosdetectarjuntospoligonos))
```

```{r}
manzanasdetectAR <- manzanasdetectAR %>% mutate(cobertura=ifelse(is.na(cobertura),FALSE,TRUE))
```

```{r}
manzanasindicesdetectAR <- st_join(manzanasindices,st_as_sf(isocronosdetectarjuntospoligonos))
```

```{r}
manzanasindicesdetectAR <- manzanasindicesdetectAR %>% mutate(cobertura=ifelse(is.na(cobertura),FALSE,TRUE))
```

```{r}
manzanasindicesdetectAR <- filter(manzanasindicesdetectAR, cobertura=="TRUE")
```

```{r}
hotelesindicesdetectar <- st_join(hotelesindices, st_as_sf(isocronosdetectarjuntospoligonos))
```

```{r}
hotelesindicesdetectar <- filter(hotelesindicesdetectar, cobertura.y=="TRUE")
```


```{r fig.height=10, fig.width=10}
ggplot()+
  geom_sf(data=manzanas, aes (fill=NA), color= "grey60") +
  geom_sf(data=isocronosdetectarjuntospoligonos, aes (fill= "Polígonos DetectAR"), alpha=0.25)+
  geom_sf(data = manzanasindices, aes(fill="Manzana selecta (índice 01 y 02)"))+
    geom_sf(data = manzanasindicesdetectAR, aes (fill="Manzana selecta con cercanía DetectAR"))+
  geom_sf(data = hotelesindicesdetectar, aes(color = "Hotel selecto con cercanía DetectAR"))+
  scale_fill_manual(values = c("Manzana selecta (índice 01 y 02)" = "turquoise", "Manzana selecta con cercanía DetectAR"="olivedrab4","Polígonos DetectAR"="orange"), name=NULL)+
  scale_colour_manual(values=c("Hotel selecto con cercanía DetectAR"="salmon", "Polígonos DetectAR"="red"),name="Referencia", guide = guide_legend(override.aes = list(linetype = "blank"))) +
  labs(title="Ubicación de hoteles según polígonos DetectAr",
       subtitle="sobre la base de las manzanas selectas según índice 1 y 2",
       caption= "Fuente: BA DATA & Properati")+
  theme_void()+
  theme(plot.title = element_text(hjust=0.07, face = "bold"),
      plot.caption = element_text(size=10),
      plot.subtitle = element_text(size = 12, hjust = 0.07))
```

```{r}
InfoHotelesSeleccionados <- select(hotelesindicesdetectar, 2:3)
head(InfoHotelesSeleccionados, 66)
```


## **Conclusión**

A partir del análisis realizado de la información obtenida a partir de las bases de datos de BA Data y Properati, podemos concluir que las manzanas de mayor viabilidad para el alquiler de algún inmueble, en base a las variables consideradas a lo largo del trabajo, son las "manzanas selectas con cercanía DetectAR" (graficadas en el último mapa en color oliva). 
Ahora bien, los posibles inmuebles, ubicados en dichas manzanas, que podrían ser alquilados por el Gobierno de la Ciudad de Buenos Aires serían los hoteles mapeados en color salmón (en el último mapa) y listados en el último "head" (65 hoteles). 
A modo de sugerencia, si tuviéramos que elegir los hoteles más idoneos para alojar a los pacientes positivos COVID, lo haríamos considerando la cantidad de habitaciones y camas disponibles en cada uno, con el fin de optimizar los recursos humanos que estarán a cargo de atender a dichos pacientes. 

