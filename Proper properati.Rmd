---
title: "Properati"
author: "Santiago Soubie"
date: "2/6/2021"
output: html_document
---

# **TRABAJO PRÁCTICO FINAL**

*INTEGRANTES*
  - Florencia Kihara
  - Victoria Marco
  - Santiago Soubie

**Consigna**

*Debido a la pandemia del COVID-19, el Gobierno de la Ciudad de Buenos Aires tomó la decisión de reutilizar la capacidad hotelera preexistente para poder mejorar la capacidad de atención sanitaria para la población. Sin embargo, encontrar las ubicaciones óptimas no es una tarea trivial.*

*Por un lado, el presupuesto con el que cuenta el GCBA es limitado. Por otro lado, la zona donde estén estos nuevos centros de atención de pacientes va a depender de distintos factores como la accesibilidad y la densidad poblacional.*

*El objetivo de este trabajo es poder indicar las manzanas de la Ciudad de Buenos Aires de mayor viabilidad para el alquiler de algún inmueble en base a los siguientes criterios:*

*● Costo promedio de alquiler*

*● Métricas de accesibilidad (cercanía con avenidas, cercanía con una estación de subte y cualquier otra variable que les pueda parecer útil, tiempo de viaje, en minutos caminando o en auto, desde distintos puntos de la Ciudad)*

*● Densidad poblacional*

Antes de arrancar con nuestro trabajo, cargamos las librerías que vamos a utilizar a lo largo del proyecto.

```{r}
library(tidyverse)
library(sf)
library(leaflet)
```

Nuestro trabajo consiste en identificar los hoteles con la mejor ubicación para mejorar la capacidad de atención sanitaria de la Ciudad de Buenos Aires (CABA). En consecuencia, utilizaremos distitos datasets (espaciales y no). Estos comprenden:

- Aquellos datasets vinculados a la organización territorial de la CABA

```{r}
barriosCABA <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/mapaCABA.geojson") 
```

```{r}
radiosCensales <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/radioscensales.geojson")
```

```{r}
manzanas <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/manzanas.geojson")
```

- Aquellos vinculados a la planta del transporte

```{r}
calles <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/callejero.geojson")
```

```{r}
subte <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/estacionsubte.geojson")
```

```{r}
metrobus <- st_read("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/metrobus.geojson")
```

*Si observamos dentro del dataset "metrobus", veremos algunas paradas por fuera de la CABA. Vamos a quitarlas*

```{r}
metrobus <- filter(metrobus, METROBUS!="Metrobus Norte - Av Maipú (provincia)")
```

- Aquellos ligados a infraestructuras de salud

```{r}
hospitales <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/hospitales.geojson")
```

```{r}
csac <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/csac.geojson")
```

- Aquel que contiene los alojamientos de la CABA

```{r}
hoteles <- read_sf("https://raw.githubusercontent.com/SSoubie/MEU-Hackers/main/Datasets/alojamientos.geojson")
```

*Graficamos*

```{r}
ggplot() + 
  geom_sf(data=manzanas, fill="grey", color="NA")+
  geom_sf(data=hoteles, color="red")+
  geom_sf(data=hospitales, color="green3", size=2)+
  geom_sf(data=subte, color="yellow", size=3)+
  theme_void()
```

- Aquel que posee el precio de las propiedades en alquiler

```{r}
properati <- read.csv("C:/Users/Santi/Desktop/Santi/Ciencia de Datos/Instrumento de Analisis Urbano/TP/Datasets/properati.csv",
                      stringsAsFactors = TRUE,
                      encoding = "UTF-8")
```

*Al ser tantos registros, para asegurarnos de que la base de datos solo contenga valores únicos, aplicaremos la función unique*

```{r}
properati <- unique(properati)
```

Empezaremos por trabajar sobre este último dataset debido a que es necesario intervenir el mismo para poder obtener la información necesaria para nuestro proyecto.

1º Extraemos el año de la columna "created_on" para poder filtrar los casos del año 2021.
2º Seleccionamos aquellos casos donde existe información precisa para la CABA.
3º Pesificamos los precios de los alquileres en dolares al valor de referencia de $150 a fin de homogeneizar la unidad de valor para todos los regitros. 
4º Eliminamos las columnas que no serán de utilidad para nuestro trabajo. 

```{r}
properati2021 <- properati %>% 
  separate(created_on, c("ano", "mes", "dia"), sep = "-") %>% 
  filter(ano=="2021" & l2=="Capital Federal" & price!="NA" & currency!="") %>% 
  mutate(precio=ifelse(currency=="USD", price*150, price*1)) %>% 
  rename(barrios=l3) %>% 
  select(-start_date, -end_date, -mes, -dia, -l4, -l5, -l6, -price, -currency)
```

## Optamos por quedarnos unicamente con los registros correspondientes a Departamentos y Oficinas porque....JUSTIFICAR

```{r}
properati2021 <- filter(properati2021, property_type %in% c("Departamento", "Oficina"))
```

Ahora calcularemos el precio del metro cuadrado (m2). Para ello:

1º Quitaremos los casos que no cuenten con ninguna superficie medible (total y/o cubierta).
2º Crearemos una columna que contenga la superficie total, o, en detrimento, la cubierta.
3º Calcularemos el precio del m2.
*4º Quitaremos los casos menores a 32 m2 y mayores a 75000m2.* Por qé 32? nuevo código de edificación JUSTIFICACIÓN

```{r}
properati2021 <- properati2021 %>% 
  filter(!(surface_covered=="NA" & surface_total=="NA")) %>% 
  mutate(superficie=ifelse(is.na(surface_total), surface_covered, surface_total),
         metro2=precio/superficie,
         metro2=round(metro2,0)) %>% 
  filter(superficie>=32 & superficie<=7500)
```

Luego, queremos clasificar los alquileres en categorías según su valor. Entonces:

1º Creamos el vector que va a establecer los quiebres

```{r}
quiebres <- c(0,0.2,0.4,0.6,0.8,1)
```

2º Clasificamos los valores de acuerdo a categorías 

```{r}
properati2021 <- mutate(properati2021, catmetro2=cut(metro2,breaks = quantile(metro2,quiebres,na.rm = TRUE, dig.lab = 5),include.lowest = TRUE))
```

*Modificamos las etiquetas para que sea más simple comprenderlas*

```{r}
properati2021 <- mutate(properati2021, catmetro2=as.numeric(catmetro2),
                        catmetro2 = recode(catmetro2, "1"="Muy bajo", "2"="Bajo", "3"="Medio", "4"="Alto", "5"="Muy alto"))
```

Veamos que tenemos hasta el momento. Analicemos los valores del m2 de acuerdo a las dimensiones de los inmuebles. Para ello, primero clasifiquemos a los mismos en categorías de acuerdo a su tamaño. Luego, graficaremos.

```{r}
properati2021 <- mutate(properati2021, superficiecat=ifelse(superficie %in% 32:55, "Chico",
                                                     ifelse(superficie %in% 56:75, "Mediano",
                                                     ifelse(superficie %in% 76:150, "Grande", "Muy grande"))))
```

```{r}
properati2021 <- mutate(properati2021, superficiecat=factor(superficiecat, levels = c ("Chico", "Mediano", "Grande", "Muy grande")))

ggplot(data = properati2021) +
    geom_boxplot(aes(x=superficiecat, y=metro2), show.legend = FALSE)
```

A partir de este boxplot, podemos ver que identificamos valores extremos que sesgan nuestra muestra. Por este motivo, nuestro siguiente paso será quitar todos aquellos casos en los que el valor del m2 supere los 50.000 pesos.

```{r}
properati2021 <- filter(properati2021, metro2<50000)
```

*Graficamos nuevamente*

```{r}
ggplot(data = properati2021) +
    geom_boxplot(aes(x=superficiecat, y=metro2), show.legend = FALSE)
```

A través de este nuevo boxplot, podemos comprobar que continuan existiendo outliers, pero su magnitud no es tan extrema (comparativamente con los casos ya borrados), y, por lo tanto, no serán eliminados. 

Por último, procederemos a componer un mapa que nos permita visualizar la ubicación de las unidades de nuestro dataset, a fin de poder identificar las zonas más significativas para nuestro análisis. Con este fin:

1º Quitaremos todos los valores que no puedan ser ubicados en el mapa.

```{r}
properati2021 <- filter(properati2021, !(lon=="NA" & lat=="NA"))
```

2º Transformaremos nuestro dataset en uno espacial.

```{r}
properati2021 <- st_as_sf(properati2021,
                           coords = c("lon","lat"),
                           crs = 4326)
```

*Graficamos para ver nuestro resultado hasta el momento*

```{r}
properati2021 <- mutate(properati2021, catmetro2=factor(catmetro2, levels = c ("Muy bajo", "Bajo", "Medio", "Alto", "Muy alto")))

ggplot()+
  geom_sf(data=barriosCABA) +
  geom_sf(data=properati2021, aes(color=catmetro2), size=3)+
  scale_color_viridis_d() +
  theme_minimal()
```

3º Como podemos observar en nuestro dataset, la variable barrios contiene más que los que son oficialmente reconocidos. Para poder asignarlos de forma precisa, unimos nuestro dataset con el dataset "barriosCABA".

```{r}
properati2021<- st_join(barriosCABA,properati2021)
```
*Gracias a este último paso, podemos ver que nos valores extremos de Versalles, en realidad, se encuentran mal geolocalizados. Vamos a quitarlos*

```{r}
filter(properati2021, barrio=="VERSALLES") 
```

```{r}
properati2021 <- filter(properati2021, !(barrio=="VERSALLES" & barrios=="Catalinas"))
```

4º Agrupamos los registros y calculamos la media del m2 por barrio.

```{r}
properati2021barrios <- properati2021 %>% 
  group_by(barrio) %>% 
  summarise(promediometro2=mean(metro2)) %>% 
  mutate(promediometro2=round(promediometro2, 2))
```

*Graficamos*

```{r}
ggplot() +
  geom_sf(data=barriosCABA)+
  geom_sf (data=properati2021barrios, aes(fill=promediometro2)) +
  scale_fill_viridis_c() +
  theme_void()
```

Unimos nuestro dataset al de radio censales que contiene la información por barrio

```{r}
properati2021barrios <- properati2021barrios %>% 
  as.data.frame() %>% 
  select(barrio, promediometro2) %>% 
  rename(BARRIO=barrio)
radiosCensales <- left_join(radiosCensales, properati2021barrios, by="BARRIO")
```

--------------------------------------------------------------------------------

Previo a seleccionar los hoteles con la mejor ubicación para mejorar la capacidad de atención sanitaria de la CABA, es necesario identificar las manzanas de la ciudad que cumplen con ciertos requisitos.

Puesto que trabajaremos con distintos datasets espaciales, homogeneizaremos los sistemas de coordenadas. Como referencia, utilizaremos el sitema de coordenadas que emplea el GCBA.

```{r}
hospitales <- st_transform(hospitales, crs="+proj=tmerc +lat_0=-34.6297166 +lon_0=-58.4627 +k=1 +x_0=100000 +y_0=100000 +ellps=intl +units=m +no_defs")
csac <- st_transform(csac, crs=st_crs(hospitales))
metrobus <- st_transform(metrobus, crs = st_crs(hospitales))
subte <- st_transform(subte, crs = st_crs(hospitales))
hoteles <- st_transform(hoteles, crs=st_crs(hospitales))
mapaCABA <- st_transform(barriosCABA, crs = st_crs(hospitales))
manzanas <- st_transform(manzanas, crs = st_crs(hospitales))
calles <- st_transform(calles, crs = st_crs(hospitales))
radiosCensales <- st_transform(radiosCensales, crs = st_crs(hospitales))
```

Queremos que las manzanas que elijamos se encuentren, como mucho, a 1000 mts de un hospitales públicos y a 1500 mts de un Csac.

```{r}
coberturaHospitales <- hospitales %>% 
    st_buffer(dist = 1000) %>%
    summarise(cobertura=TRUE)
```

```{r}
coberturacsac <- csac %>% 
    st_buffer(dist = 1500) %>%
    summarise(cobertura=TRUE)
```

Este punto lo retomaremos más adelate. Por ahora, solo graficamos por el momento.

```{r}
ggplot()+
  geom_sf(data=barriosCABA, fill="NA")+
  geom_sf(data=coberturacsac, fill="green")+
  geom_sf(data=coberturaHospitales, fill="red")+
  geom_sf(data=hoteles, color="black")+
  theme_void()
```

Otra de las condiciones que debe cumplir nuestra manzana es que sea de fácil acceso. En este sentido, las mismas deben encontrarse a una distancia prudencial de las estaciones de subte, de metrobus y las avenidas. Con ello en mente:

1º Como un extremo de una manzana puede estar más cerca de una ubicación que otro y, a su vez, dado que una manzana puede poseer una forma irrregular, calcularemos la distancia desde el centro. Por este motivo, nuestro primer paso será extraer los centros de manzanas.

```{r}
manzanacentroide <- st_centroid(manzanas)
```

2º Hacemos un dataset que solo contenga las avenidas de CABA.

```{r}
avenidas <- filter(calles, tipo_c=="AVENIDA")
```

*Graficamos para ver los centroides de manzana*

```{r fig.height=15, fig.width=15}
ggplot()+ geom_sf(data = manzanas, fill = "NA") +
  geom_sf(data = manzanacentroide, color = "blue", size = 0.001)+
  geom_sf(data = avenidas, color = "red")+
  geom_sf(data = subte, color = "seagreen4", size = 5)+
  geom_sf(data = metrobus, color = "orange", size = 3)+
  theme_void()
```

3º Calculamos la distancia desde los centroides de manzana a los distintos puntos de transporte

```{r}
distanciavenida <- st_distance(manzanacentroide, avenidas)

distanciasubte <- st_distance(manzanacentroide, subte)

distanciametrobus <- st_distance(manzanacentroide, metrobus)
```

4º Como el paso anterior nos devolvió todas las distacias posibles de nuestra manzana a todos los puntos de transporte, solo nos vamos a quedar con las de menor tamaño.

```{r}
avenidacercana <- apply(distanciavenida,1,function(x) min(x))
```

```{r}
subtecercano <- apply(distanciasubte,1, function(x) min(x))
metrobuscercano <- apply(distanciametrobus,1, function(x) min(x))
```

*Redondeamos los valores*

```{r}
avenidacercana <- round(avenidacercana, 0)
subtecercano <- round(subtecercano, 0)
metrobuscercano <- round(metrobuscercano, 0)
```

5º Agregamos las distancias al dataset de manzanas

```{r}
manzanas <- mutate(manzanas, distanciaavenida=avenidacercana,
                   distanciasubte=subtecercano,
                   distanciametrobus=metrobuscercano)
```

*Graficamos*

*PONER POR QUE ELEGIMOS ESAS DISTANCIAS

```{r}
ggplot()+
  geom_sf(data=manzanas, fill="NA")+
  geom_sf(data=filter(manzanas, distanciametrobus<=500 & distanciasubte<=500 & distanciaavenida<=200), fill="red")+
  theme_void()
```

Retomemos la cuestión de la cobertura de los hospitales y Cesacs. Nosotros solo nos interesa quedarnos con aquellas manzanas que se encuentren a menos de 1000 mts de los hospitales, y a 1500 mts de los Cesacs. Para averguar cuales son:

1º Unimos el dataset de centroides de manzana con los de cobertura de hospitales y Cesacs. 

```{r}
manzanacentroide <- st_join(manzanacentroide, coberturaHospitales)
manzanacentroide <- st_join(manzanacentroide, coberturacsac)
```

*Renombramos las columnas*

```{r}
manzanacentroide <- rename(manzanacentroide, "cobhospitales"=cobertura.x,
                           "cobcesac"=cobertura.y)
```

*Graficamos*

```{r}
ggplot()+
  geom_sf(data = manzanas, fill="NA")+
  geom_sf(data = filter(manzanacentroide, cobhospitales=="TRUE" & cobcesac=="TRUE"), color="red")+
  theme_void()
```

Otro factor que tendremos en cuenta es el de densidad poblacional. Nuestro objetivo es seleccionar aquellas manzanas que cumplan con un determinado parámetro de densidad. Para calcular la misma: 

1º Creamos una columna que contenga la población por km2 de cada radio censal.

```{r}
radiosCensales <- mutate(radiosCensales, densidadPob=round(POBLACION/AREA_KM2, 2))
```

*Graficamos*

```{r}
ggplot() +
  geom_sf(data = radiosCensales, aes(fill=densidadPob))+
  scale_fill_viridis_c()+
  theme_void()
```

2º Unimos el dataset de los radios censales al de manzanas centroides.

```{r}
manzanacentroide <- st_join(manzanacentroide,radiosCensales)
```

Una vez finalizados estos pasos, seleccionamos las columnas de interés del dataset manzanascentroide y las volcamos a nuestro dataset de manzanas.

```{r}
manzanacentroide <- manzanacentroide %>% 
                      as.data.frame() %>%
                      select(SM, cobhospitales, cobcesac, promediometro2, densidadPob)
manzanas <- left_join(manzanas, manzanacentroide, by="SM")
```

*Al unir nuestros datasets, vemos que se suman más casos de los que debería haber (12588 frente a 12520). Averiguamos si se generaron duplicados*

```{r}
duplicados <- duplicated(manzanas, incomparables = FALSE)
```

```{r}
summary(duplicados)
```

*Efectivamente, algunos registros fueron duplicados. Por ello, procederemos  a quedarnos solo con los valores únicos*

```{r}
manzanas <- unique(manzanas)
```

Ahora, Creamos un dataset que cuente con las manzanas que cumplen con las condiciones que pensamos

```{r}
manzanaselecta <- filter(manzanas, cobhospitales==TRUE & cobcesac==TRUE & densidadPob>=16576 & distanciametrobus<=500 & distanciasubte<=500 & distanciaavenida<=200 & promediometro2<=642)
```

```{r fig.height=15, fig.width=15}
ggplot()+geom_sf(data=manzanas, fill="NA")+
        geom_sf(data=manzanaselecta, fill="red")+
        geom_sf(data=hoteles, color="blue")+
        theme_void()
```

## ACÄ HABRÏA QUE PONER: 1º UNA CONCLUSIÖN y 2º UNA JUSTIFICACIÖN DEL PORQUË DECIDIMOS AVANZAR CON UN ÍNDICE

```{r}
ggplot() +
  geom_sf(data=manzanas)+
  geom_sf(data = filter(manzanas, is.na(promediometro2)), fill="red")+
  theme_void()

#Este gráfico los vamos a dejar o lo vamos a volar? Yo lo volaría

```
